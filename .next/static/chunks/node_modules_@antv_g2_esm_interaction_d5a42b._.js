(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_@antv_g2_esm_interaction_d5a42b._.js", {

"[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "bboxOf": (()=>bboxOf),
    "boundsOfBrushArea": (()=>boundsOfBrushArea),
    "brushMousePosition": (()=>brushMousePosition),
    "createColorKey": (()=>createColorKey),
    "createDatumof": (()=>createDatumof),
    "createValueof": (()=>createValueof),
    "createXKey": (()=>createXKey),
    "getElements": (()=>getElements),
    "getPointsPath": (()=>getPointsPath),
    "getPointsR": (()=>getPointsR),
    "getThetaPath": (()=>getThetaPath),
    "maybeRoot": (()=>maybeRoot),
    "mergeState": (()=>mergeState),
    "mousePosition": (()=>mousePosition),
    "offsetTransform": (()=>offsetTransform),
    "renderBackground": (()=>renderBackground),
    "renderLink": (()=>renderLink),
    "restoreCursor": (()=>restoreCursor),
    "selectElementByData": (()=>selectElementByData),
    "selectFacetG2Elements": (()=>selectFacetG2Elements),
    "selectFacetViews": (()=>selectFacetViews),
    "selectG2Elements": (()=>selectG2Elements),
    "selectPlotArea": (()=>selectPlotArea),
    "setCursor": (()=>setCursor),
    "useState": (()=>useState)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/g/dist/index.esm.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$selection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/selection.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/constant.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g-lite/dist/index.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/style.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sort$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__sort$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/sort.js [app-client] (ecmascript) <export default as sort>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$path$2f$src$2f$path$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-path/src/path.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/coordinate.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$shape$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/shape/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/scale.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$shape$2f$interval$2f$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/shape/interval/color.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$filter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__filter$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/filter.js [app-client] (ecmascript) <export default as filter>");
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
;
;
;
;
;
;
;
;
;
;
;
function selectG2Elements(root) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$selection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["select"])(root).selectAll(`.${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ELEMENT_CLASS_NAME"]}`).nodes().filter((d)=>!d.__removed__);
}
function selectFacetG2Elements(target, viewInstances) {
    return selectFacetViews(target, viewInstances).flatMap(({ container })=>selectG2Elements(container));
}
function selectFacetViews(target, viewInstances) {
    return viewInstances.filter((d)=>d !== target && d.options.parentKey === target.options.key);
}
function selectPlotArea(root) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$selection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["select"])(root).select(`.${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PLOT_CLASS_NAME"]}`).node();
}
function bboxOf(element) {
    // The geometry bounds of a group is empty, so return the render bounds.
    if (element.tagName === 'g') return element.getRenderBounds();
    // Compute the geometry bounds related to the parent.
    const bounds = element.getGeometryBounds();
    const aabb = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AABB"]();
    aabb.setFromTransformedAABB(bounds, element.getWorldTransform());
    return aabb;
}
function mousePosition(target, event) {
    const { offsetX, offsetY } = event;
    const bbox = bboxOf(target);
    const { min: [x, y], max: [x1, y1] } = bbox;
    const isOutX = offsetX < x || offsetX > x1;
    const isOutY = offsetY < y || offsetY > y1;
    if (isOutX || isOutY) return null;
    return [
        offsetX - x,
        offsetY - y
    ];
}
function brushMousePosition(target, event) {
    const { offsetX, offsetY } = event;
    const [x, y, x1, y1] = boundsOfBrushArea(target);
    return [
        Math.min(x1, Math.max(x, offsetX)) - x,
        Math.min(y1, Math.max(y, offsetY)) - y
    ];
}
function boundsOfBrushArea(target) {
    // Calc bbox after clipping.
    const bbox = target.getRenderBounds();
    const { min: [x0, y0], max: [x1, y1] } = bbox;
    return [
        x0,
        y0,
        x1,
        y1
    ];
}
function createColorKey(view) {
    return (element)=>element.__data__.color;
}
function createXKey(view) {
    return (element)=>element.__data__.x;
}
function createDatumof(view) {
    const views = Array.isArray(view) ? view : [
        view
    ];
    const keyData = new Map(views.flatMap((view)=>{
        const marks = Array.from(view.markState.keys());
        return marks.map((mark)=>[
                keyed(view.key, mark.key),
                mark.data
            ]);
    }));
    return (element)=>{
        const { index, markKey, viewKey } = element.__data__;
        const data = keyData.get(keyed(viewKey, markKey));
        return data[index];
    };
}
function useState(style, valueof = (d, element)=>d, setAttribute = (element, key, v)=>element.setAttribute(key, v)) {
    const STATES = '__states__';
    const ORIGINAL = '__ordinal__';
    // Mix style for each state and apply it to element.
    const updateState = (element)=>{
        const { [STATES]: states = [], [ORIGINAL]: original = {} } = element;
        const stateStyle = states.reduce((mixedStyle, state)=>Object.assign(Object.assign({}, mixedStyle), style[state]), original);
        if (Object.keys(stateStyle).length === 0) return;
        for (const [key, value] of Object.entries(stateStyle)){
            const currentValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getStyle"])(element, key);
            const v = valueof(value, element);
            setAttribute(element, key, v);
            // Store the attribute if it does not exist in original.
            if (!(key in original)) original[key] = currentValue;
        }
        element[ORIGINAL] = original;
    };
    const initState = (element)=>{
        if (element[STATES]) return;
        element[STATES] = [];
        return;
    };
    /**
     * Set the states and update element.
     */ const setState = (element, ...states)=>{
        initState(element);
        element[STATES] = [
            ...states
        ];
        updateState(element);
    };
    /**
     * Remove the states and update element.
     */ const removeState = (element, ...states)=>{
        initState(element);
        for (const state of states){
            const index = element[STATES].indexOf(state);
            if (index !== -1) {
                element[STATES].splice(index, 1);
            }
        }
        updateState(element);
    };
    const hasState = (element, state)=>{
        initState(element);
        return element[STATES].indexOf(state) !== -1;
    };
    return {
        setState,
        removeState,
        hasState
    };
}
function isEmptyObject(obj) {
    if (obj === undefined) return true;
    if (typeof obj !== 'object') return false;
    return Object.keys(obj).length === 0;
}
// A function to generate key for mark each view.
function keyed(viewKey, markKey) {
    return `${viewKey},${markKey}`;
}
function mergeState(options, states) {
    // Index state by mark key and view key.
    const views = Array.isArray(options) ? options : [
        options
    ];
    const markState = views.flatMap((view)=>view.marks.map((mark)=>[
                keyed(view.key, mark.key),
                mark.state
            ]));
    const state = {};
    // Update each specified state.
    for (const descriptor of states){
        const [key, defaults] = Array.isArray(descriptor) ? descriptor : [
            descriptor,
            {}
        ];
        // Update each specified mark state.
        state[key] = markState.reduce((merged, mark)=>{
            // Normalize state.
            const [markKey, markState = {}] = mark;
            const selectedState = isEmptyObject(markState[key]) ? defaults : markState[key];
            // Update each state attribute.
            for (const [attr, value] of Object.entries(selectedState)){
                const oldValue = merged[attr];
                const newValue = (data, index, array, element)=>{
                    const k = keyed(element.__data__.viewKey, element.__data__.markKey);
                    if (markKey !== k) return oldValue === null || oldValue === void 0 ? void 0 : oldValue(data, index, array, element);
                    if (typeof value !== 'function') return value;
                    return value(data, index, array, element);
                };
                merged[attr] = newValue;
            }
            return merged;
        }, {});
    }
    return state;
}
function createValueof(elements, datum) {
    const elementIndex = new Map(elements.map((d, i)=>[
            d,
            i
        ]));
    const fa = datum ? elements.map(datum) : elements;
    return (d, e)=>{
        if (typeof d !== 'function') return d;
        const i = elementIndex.get(e);
        const fe = datum ? datum(e) : e;
        return d(fe, i, fa, e);
    };
}
function renderLink(_a) {
    var { link = false, valueof = (d, element)=>d, coordinate } = _a, style = __rest(_a, [
        "link",
        "valueof",
        "coordinate"
    ]);
    const LINK_CLASS_NAME = 'element-link';
    if (!link) return [
        ()=>{},
        ()=>{}
    ];
    const pointsOf = (element)=>element.__data__.points;
    const pathPointsOf = (P0, P1)=>{
        const [, p1, p2] = P0;
        const [p0, , , p3] = P1;
        const P = [
            p1,
            p0,
            p3,
            p2
        ];
        return P;
    };
    const append = (elements)=>{
        var _a;
        if (elements.length <= 1) return;
        // Sort elements by normalized x to avoid cross.
        const sortedElements = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sort$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__sort$3e$__["sort"])(elements, (e0, e1)=>{
            const { x: x0 } = e0.__data__;
            const { x: x1 } = e1.__data__;
            const dx = x0 - x1;
            return dx;
        });
        for(let i = 1; i < sortedElements.length; i++){
            const p = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$path$2f$src$2f$path$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["path"])();
            const e0 = sortedElements[i - 1];
            const e1 = sortedElements[i];
            const [p0, p1, p2, p3] = pathPointsOf(pointsOf(e0), pointsOf(e1));
            p.moveTo(...p0);
            p.lineTo(...p1);
            p.lineTo(...p2);
            p.lineTo(...p3);
            p.closePath();
            const _b = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mapObject"])(style, (d)=>valueof(d, e0)), { fill = e0.getAttribute('fill') } = _b, rest = __rest(_b, [
                "fill"
            ]);
            const link = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"]({
                className: LINK_CLASS_NAME,
                style: Object.assign({
                    d: p.toString(),
                    fill,
                    zIndex: -2
                }, rest)
            });
            // @ts-ignore
            (_a = e0.link) === null || _a === void 0 ? void 0 : _a.remove();
            e0.parentNode.appendChild(link);
            // @ts-ignore
            e0.link = link;
        }
    };
    const remove = (element)=>{
        var _a;
        (_a = element.link) === null || _a === void 0 ? void 0 : _a.remove();
        element.link = null;
    };
    return [
        append,
        remove
    ];
}
function offsetTransform(element, offset, coordinate) {
    const append = (t)=>{
        const { transform } = element.style;
        return transform ? `${transform} ${t}` : t;
    };
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPolar"])(coordinate)) {
        const { points } = element.__data__;
        const [p0, p1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTranspose"])(coordinate) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$shape$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reorder"])(points) : points;
        const center = coordinate.getCenter();
        const v0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sub"])(p0, center);
        const v1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sub"])(p1, center);
        const a0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["angle"])(v0);
        const da = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["angleBetween"])(v0, v1);
        const amid = a0 + da / 2;
        const dx = offset * Math.cos(amid);
        const dy = offset * Math.sin(amid);
        return append(`translate(${dx}, ${dy})`);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTranspose"])(coordinate)) return append(`translate(${offset}, 0)`);
    return append(`translate(0, ${-offset})`);
}
function renderBackground(_a) {
    var { document, background, scale, coordinate, valueof } = _a, rest = __rest(_a, [
        "document",
        "background",
        "scale",
        "coordinate",
        "valueof"
    ]);
    const BACKGROUND_CLASS_NAME = 'element-background';
    // Don't have background.
    if (!background) return [
        ()=>{},
        ()=>{}
    ];
    const extentOf = (scale, x, padding)=>{
        const ax = scale.invert(x);
        const mid = x + scale.getBandWidth(ax) / 2;
        const half = scale.getStep(ax) / 2;
        const offset = half * padding;
        return [
            mid - half + offset,
            mid + half - offset
        ];
    };
    const sizeXOf = (element, padding)=>{
        const { x: scaleX } = scale;
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOrdinalScale"])(scaleX)) return [
            0,
            1
        ];
        const { __data__: data } = element;
        const { x } = data;
        const [e1, e2] = extentOf(scaleX, x, padding);
        return [
            e1,
            e2
        ];
    };
    const sizeYOf = (element, padding)=>{
        const { y: scaleY } = scale;
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOrdinalScale"])(scaleY)) return [
            0,
            1
        ];
        const { __data__: data } = element;
        const { y } = data;
        const [e1, e2] = extentOf(scaleY, y, padding);
        return [
            e1,
            e2
        ];
    };
    const bandShapeOf = (element, style)=>{
        const { padding } = style;
        const [x1, x2] = sizeXOf(element, padding);
        const [y1, y2] = sizeYOf(element, padding);
        const points = [
            [
                x1,
                y1
            ],
            [
                x2,
                y1
            ],
            [
                x2,
                y2
            ],
            [
                x1,
                y2
            ]
        ].map((d)=>coordinate.map(d));
        const { __data__: data } = element;
        const { y: dy, y1: dy1 } = data;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$shape$2f$interval$2f$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rect"])(document, points, {
            y: dy,
            y1: dy1
        }, coordinate, style);
    };
    // Shape without ordinal style.
    // Clone and scale it.
    const cloneShapeOf = (element, style)=>{
        const { transform = 'scale(1.2, 1.2)', transformOrigin = 'center center', stroke = '' } = style, rest = __rest(style, [
            "transform",
            "transformOrigin",
            "stroke"
        ]);
        const finalStyle = Object.assign({
            transform,
            transformOrigin,
            stroke
        }, rest);
        const shape = element.cloneNode(true);
        for (const [key, value] of Object.entries(finalStyle)){
            shape.style[key] = value;
        }
        return shape;
    };
    const isOrdinalShape = ()=>{
        const { x, y } = scale;
        return [
            x,
            y
        ].some(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOrdinalScale"]);
    };
    const append = (element)=>{
        if (element.background) element.background.remove();
        const _a = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mapObject"])(rest, (d)=>valueof(d, element)), { fill = '#CCD6EC', fillOpacity = 0.3, zIndex = -2, padding = 0.001, lineWidth = 0 } = _a, style = __rest(_a, [
            "fill",
            "fillOpacity",
            "zIndex",
            "padding",
            "lineWidth"
        ]);
        const finalStyle = Object.assign(Object.assign({}, style), {
            fill,
            fillOpacity,
            zIndex,
            padding,
            lineWidth
        });
        const shapeOf = isOrdinalShape() ? bandShapeOf : cloneShapeOf;
        const shape = shapeOf(element, finalStyle);
        shape.className = BACKGROUND_CLASS_NAME;
        element.parentNode.parentNode.appendChild(shape);
        element.background = shape;
    };
    const remove = (element)=>{
        var _a;
        (_a = element.background) === null || _a === void 0 ? void 0 : _a.remove();
        element.background = null;
    };
    const is = (element)=>{
        return element.className === BACKGROUND_CLASS_NAME;
    };
    return [
        append,
        remove,
        is
    ];
}
function setCursor(root, cursor) {
    // @ts-ignore
    const canvas = root.getRootNode().defaultView;
    const dom = canvas.getContextService().getDomElement();
    if (dom === null || dom === void 0 ? void 0 : dom.style) {
        root.cursor = dom.style.cursor;
        dom.style.cursor = cursor;
    }
}
function restoreCursor(root) {
    setCursor(root, root.cursor);
}
function selectElementByData(elements, data, datum) {
    return elements.find((d)=>Object.entries(data).every(([key, value])=>datum(d)[key] === value));
}
function getPointsR(point, nextPoint) {
    return Math.sqrt(Math.pow(point[0] - nextPoint[0], 2) + Math.pow(point[1] - nextPoint[1], 2));
}
function getPointsPath(points, isClose = false) {
    const path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$filter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__filter$3e$__["filter"])(points, (d)=>!!d).map((d, i)=>{
        return [
            i === 0 ? 'M' : 'L',
            ...d
        ];
    });
    if (isClose) {
        path.push([
            'Z'
        ]);
    }
    return path;
}
function getElements(plot) {
    return plot.querySelectorAll('.element');
}
function getThetaPath(center, points, isBig = 0) {
    const path = [
        [
            'M',
            ...points[1]
        ]
    ];
    const innerRadius = getPointsR(center, points[1]);
    const outerRadius = getPointsR(center, points[0]);
    if (innerRadius === 0) {
        path.push([
            'L',
            ...points[3]
        ], [
            'A',
            outerRadius,
            outerRadius,
            0,
            isBig,
            1,
            ...points[0]
        ], [
            'Z'
        ]);
    } else {
        path.push([
            'A',
            innerRadius,
            innerRadius,
            0,
            isBig,
            0,
            ...points[2]
        ], [
            'L',
            ...points[3]
        ], [
            'A',
            outerRadius,
            outerRadius,
            0,
            isBig,
            1,
            ...points[0]
        ], [
            'Z'
        ]);
    }
    return path;
}
function maybeRoot(node, rootOf) {
    if (rootOf(node)) return node;
    let root = node.parent;
    while(root && !rootOf(root))root = root.parent;
    return root;
} //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/elementHighlight.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ElementHighlight": (()=>ElementHighlight),
    "elementHighlight": (()=>elementHighlight)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/group.js [app-client] (ecmascript) <export default as group>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/deep-mix.js [app-client] (ecmascript) <export default as deepMix>");
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
;
;
function elementHighlight(root, { elements: elementsof, datum, groupKey = (d)=>d, link = false, background = false, delay = 60, scale, coordinate, emitter, state = {} }) {
    var _a;
    const elements = elementsof(root);
    const elementSet = new Set(elements);
    const keyGroup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__["group"])(elements, groupKey);
    const valueof = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createValueof"])(elements, datum);
    const [appendLink, removeLink] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["renderLink"])(Object.assign({
        elements,
        valueof,
        link,
        coordinate
    }, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(state.active, 'link')));
    const [appendBackground, removeBackground, isBackground] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["renderBackground"])(Object.assign({
        document: root.ownerDocument,
        scale,
        coordinate,
        background,
        valueof
    }, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(state.active, 'background')));
    const elementStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])(state, {
        active: Object.assign({}, ((_a = state.active) === null || _a === void 0 ? void 0 : _a.offset) && {
            //Apply translate to mock slice out.
            transform: (...params)=>{
                const value = state.active.offset(...params);
                const [, i] = params;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["offsetTransform"])(elements[i], value, coordinate);
            }
        })
    });
    const { setState, removeState, hasState } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(elementStyle, valueof);
    let out; // Timer for delaying unhighlighted.
    const pointerover = (event)=>{
        const { target: element, nativeEvent = true } = event;
        if (!elementSet.has(element)) return;
        if (out) clearTimeout(out);
        const k = groupKey(element);
        const group = keyGroup.get(k);
        const groupSet = new Set(group);
        for (const e of elements){
            if (groupSet.has(e)) {
                if (!hasState(e, 'active')) setState(e, 'active');
            } else {
                setState(e, 'inactive');
                removeLink(e);
            }
            if (e !== element) removeBackground(e);
        }
        appendBackground(element);
        appendLink(group);
        // Emit events.
        if (!nativeEvent) return;
        emitter.emit('element:highlight', {
            nativeEvent,
            data: {
                data: datum(element),
                group: group.map(datum)
            }
        });
    };
    const delayUnhighlighted = ()=>{
        if (out) clearTimeout(out);
        out = setTimeout(()=>{
            unhighlighted();
            out = null;
        }, delay);
    };
    const unhighlighted = (nativeEvent = true)=>{
        for (const e of elements){
            removeState(e, 'active', 'inactive');
            removeBackground(e);
            removeLink(e);
        }
        if (nativeEvent) {
            emitter.emit('element:unhighlight', {
                nativeEvent
            });
        }
    };
    const pointerout = (event)=>{
        const { target: element } = event;
        if (background && !isBackground(element)) return;
        if (!background && !elementSet.has(element)) return;
        if (delay > 0) delayUnhighlighted();
        else unhighlighted();
    };
    const pointerleave = ()=>{
        unhighlighted();
    };
    root.addEventListener('pointerover', pointerover);
    root.addEventListener('pointerout', pointerout);
    root.addEventListener('pointerleave', pointerleave);
    const onRest = (e)=>{
        const { nativeEvent } = e;
        if (nativeEvent) return;
        unhighlighted(false);
    };
    const onHighlight = (e)=>{
        const { nativeEvent } = e;
        if (nativeEvent) return;
        const { data } = e.data;
        const element = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectElementByData"])(elements, data, datum);
        if (!element) return;
        pointerover({
            target: element,
            nativeEvent: false
        });
    };
    emitter.on('element:highlight', onHighlight);
    emitter.on('element:unhighlight', onRest);
    return ()=>{
        root.removeEventListener('pointerover', pointerover);
        root.removeEventListener('pointerout', pointerout);
        root.removeEventListener('pointerleave', pointerleave);
        emitter.off('element:highlight', onHighlight);
        emitter.off('element:unhighlight', onRest);
        for (const e of elements){
            removeBackground(e);
            removeLink(e);
        }
    };
}
function ElementHighlight(_a) {
    var { delay, createGroup, background = false, link = false } = _a, rest = __rest(_a, [
        "delay",
        "createGroup",
        "background",
        "link"
    ]);
    return (context, _, emitter)=>{
        const { container, view, options } = context;
        const { scale, coordinate } = view;
        const plotArea = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectPlotArea"])(container);
        return elementHighlight(plotArea, Object.assign({
            elements: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectG2Elements"],
            datum: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDatumof"])(view),
            groupKey: createGroup ? createGroup(view) : undefined,
            coordinate,
            scale,
            state: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeState"])(options, [
                [
                    'active',
                    background ? {} : {
                        lineWidth: '1',
                        stroke: '#000'
                    }
                ],
                'inactive'
            ]),
            background,
            link,
            delay,
            emitter
        }, rest));
    };
}
ElementHighlight.props = {
    reapplyWhenUpdate: true
}; //# sourceMappingURL=elementHighlight.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/elementHighlightByX.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ElementHighlightByX": (()=>ElementHighlightByX)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$elementHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/elementHighlight.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
;
;
function ElementHighlightByX(options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$elementHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ElementHighlight"])(Object.assign(Object.assign({}, options), {
        createGroup: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createXKey"]
    }));
}
ElementHighlightByX.props = {
    reapplyWhenUpdate: true
}; //# sourceMappingURL=elementHighlightByX.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/elementHighlightByColor.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ElementHighlightByColor": (()=>ElementHighlightByColor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$elementHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/elementHighlight.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
;
;
function ElementHighlightByColor(options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$elementHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ElementHighlight"])(Object.assign(Object.assign({}, options), {
        createGroup: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createColorKey"]
    }));
}
ElementHighlightByColor.props = {
    reapplyWhenUpdate: true
}; //# sourceMappingURL=elementHighlightByColor.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/elementSelect.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ElementSelect": (()=>ElementSelect),
    "elementSelect": (()=>elementSelect)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/group.js [app-client] (ecmascript) <export default as group>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/deep-mix.js [app-client] (ecmascript) <export default as deepMix>");
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
;
;
function elementSelect(root, { elements: elementsof, datum, groupKey = (d)=>d, link = false, single = false, coordinate, background = false, scale, emitter, state = {} }) {
    var _a;
    const elements = elementsof(root);
    const elementSet = new Set(elements);
    const keyGroup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__["group"])(elements, groupKey);
    const valueof = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createValueof"])(elements, datum);
    const [appendLink, removeLink] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["renderLink"])(Object.assign({
        link,
        elements,
        valueof,
        coordinate
    }, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(state.selected, 'link')));
    const [appendBackground, removeBackground] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["renderBackground"])(Object.assign({
        document: root.ownerDocument,
        background,
        coordinate,
        scale,
        valueof
    }, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(state.selected, 'background')));
    const elementStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])(state, {
        selected: Object.assign({}, ((_a = state.selected) === null || _a === void 0 ? void 0 : _a.offset) && {
            //Apply translate to mock slice out.
            transform: (...params)=>{
                const value = state.selected.offset(...params);
                const [, i] = params;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["offsetTransform"])(elements[i], value, coordinate);
            }
        })
    });
    const { setState, removeState, hasState } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(elementStyle, valueof);
    const clear = (nativeEvent = true)=>{
        for (const e of elements){
            removeState(e, 'selected', 'unselected');
            removeLink(e);
            removeBackground(e);
        }
        if (nativeEvent) emitter.emit('element:unselect', {
            nativeEvent: true
        });
        return;
    };
    const singleSelect = (event, element, nativeEvent = true)=>{
        // Clear states if clicked selected element.
        if (hasState(element, 'selected')) clear();
        else {
            const k = groupKey(element);
            const group = keyGroup.get(k);
            const groupSet = new Set(group);
            for (const e of elements){
                if (groupSet.has(e)) setState(e, 'selected');
                else {
                    setState(e, 'unselected');
                    removeLink(e);
                }
                if (e !== element) removeBackground(e);
            }
            appendLink(group);
            appendBackground(element);
            if (!nativeEvent) return;
            emitter.emit('element:select', Object.assign(Object.assign({}, event), {
                nativeEvent,
                data: {
                    data: [
                        datum(element),
                        ...group.map(datum)
                    ]
                }
            }));
        }
    };
    const multipleSelect = (event, element, nativeEvent = true)=>{
        const k = groupKey(element);
        const group = keyGroup.get(k);
        const groupSet = new Set(group);
        if (!hasState(element, 'selected')) {
            const hasSelectedGroup = group.some((e)=>hasState(e, 'selected'));
            for (const e of elements){
                if (groupSet.has(e)) setState(e, 'selected');
                else if (!hasState(e, 'selected')) setState(e, 'unselected');
            }
            // Append link for each group only once.
            if (!hasSelectedGroup && link) appendLink(group);
            appendBackground(element);
        } else {
            // If there is no selected elements after resetting this group,
            // clear the states.
            const hasSelected = elements.some((e)=>!groupSet.has(e) && hasState(e, 'selected'));
            if (!hasSelected) return clear();
            // If there are still some selected elements after resetting this group,
            // only remove the link.
            for (const e of group){
                setState(e, 'unselected');
                removeLink(e);
                removeBackground(e);
            }
        }
        if (!nativeEvent) return;
        emitter.emit('element:select', Object.assign(Object.assign({}, event), {
            nativeEvent,
            data: {
                data: elements.filter((e)=>hasState(e, 'selected')).map(datum)
            }
        }));
    };
    const click = (event)=>{
        const { target: element, nativeEvent = true } = event;
        // Click non-element shape, reset.
        // Such as the rest of content area(background).
        if (!elementSet.has(element)) return clear();
        if (single) return singleSelect(event, element, nativeEvent);
        return multipleSelect(event, element, nativeEvent);
    };
    root.addEventListener('click', click);
    const onSelect = (e)=>{
        const { nativeEvent, data } = e;
        if (nativeEvent) return;
        const selectedData = single ? data.data.slice(0, 1) : data.data;
        for (const d of selectedData){
            const element = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectElementByData"])(elements, d, datum);
            click({
                target: element,
                nativeEvent: false
            });
        }
    };
    const onUnSelect = ()=>{
        clear(false);
    };
    emitter.on('element:select', onSelect);
    emitter.on('element:unselect', onUnSelect);
    return ()=>{
        for (const e of elements)removeLink(e);
        root.removeEventListener('click', click);
        emitter.off('element:select', onSelect);
        emitter.off('element:unselect', onUnSelect);
    };
}
function ElementSelect(_a) {
    var { createGroup, background = false, link = false } = _a, rest = __rest(_a, [
        "createGroup",
        "background",
        "link"
    ]);
    return (context, _, emitter)=>{
        const { container, view, options } = context;
        const { coordinate, scale } = view;
        const plotArea = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectPlotArea"])(container);
        return elementSelect(plotArea, Object.assign({
            elements: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectG2Elements"],
            datum: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDatumof"])(view),
            groupKey: createGroup ? createGroup(view) : undefined,
            coordinate,
            scale,
            state: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeState"])(options, [
                [
                    'selected',
                    background ? {} : {
                        lineWidth: '1',
                        stroke: '#000'
                    }
                ],
                'unselected'
            ]),
            background,
            link,
            emitter
        }, rest));
    };
}
ElementSelect.props = {
    reapplyWhenUpdate: true
}; //# sourceMappingURL=elementSelect.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/elementSelectByX.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ElementSelectByX": (()=>ElementSelectByX)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$elementSelect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/elementSelect.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
;
;
function ElementSelectByX(options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$elementSelect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ElementSelect"])(Object.assign(Object.assign({}, options), {
        createGroup: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createXKey"]
    }));
}
ElementSelectByX.props = {
    reapplyWhenUpdate: true
}; //# sourceMappingURL=elementSelectByX.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/elementSelectByColor.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ElementSelectByColor": (()=>ElementSelectByColor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$elementSelect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/elementSelect.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
;
;
function ElementSelectByColor(options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$elementSelect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ElementSelect"])(Object.assign(Object.assign({}, options), {
        createGroup: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createColorKey"]
    }));
}
ElementSelectByColor.props = {
    reapplyWhenUpdate: true
}; //# sourceMappingURL=elementSelectByColor.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/fisheye.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Fisheye": (()=>Fisheye)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/throttle.js [app-client] (ecmascript) <export default as throttle>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/deep-mix.js [app-client] (ecmascript) <export default as deepMix>");
;
;
function maybeCoordinate(options) {
    const { coordinate = {} } = options;
    const { transform = [] } = coordinate;
    const fisheye = transform.find((d)=>d.type === 'fisheye');
    if (fisheye) return fisheye;
    const newFisheye = {
        type: 'fisheye'
    };
    transform.push(newFisheye);
    coordinate.transform = transform;
    options.coordinate = coordinate;
    return newFisheye;
}
function Fisheye({ wait = 30, leading, trailing = false }) {
    return (context)=>{
        const { options, update, setState, container } = context;
        const plotArea = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectPlotArea"])(container);
        const updateFocus = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__["throttle"])((event)=>{
            const focus = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mousePosition"])(plotArea, event);
            if (!focus) {
                setState('fisheye');
                update();
                return;
            }
            setState('fisheye', (options)=>{
                // Clone options and mutate it.
                // Disable animation.
                const clonedOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({}, options, {
                    interaction: {
                        tooltip: {
                            preserve: true
                        }
                    }
                });
                for (const mark of clonedOptions.marks)mark.animate = false;
                const [x, y] = focus;
                const fisheye = maybeCoordinate(clonedOptions);
                fisheye.focusX = x;
                fisheye.focusY = y;
                fisheye.visual = true;
                return clonedOptions;
            });
            update();
        }, wait, {
            leading,
            trailing
        });
        // Bind events.
        plotArea.addEventListener('pointerenter', updateFocus);
        plotArea.addEventListener('pointermove', updateFocus);
        plotArea.addEventListener('pointerleave', updateFocus);
        return ()=>{
            plotArea.removeEventListener('pointerenter', updateFocus);
            plotArea.removeEventListener('pointermove', updateFocus);
            plotArea.removeEventListener('pointerleave', updateFocus);
        };
    };
} //# sourceMappingURL=fisheye.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/chartIndex.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ChartIndex": (()=>ChartIndex)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/g/dist/index.esm.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sort$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__sort$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/sort.js [app-client] (ecmascript) <export default as sort>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/constant.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/group.js [app-client] (ecmascript) <export default as group>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g-lite/dist/index.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/bisect.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/deep-mix.js [app-client] (ecmascript) <export default as deepMix>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/max.js [app-client] (ecmascript) <export default as max>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__min$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/min.js [app-client] (ecmascript) <export default as min>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/group.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__bisector$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/bisector.js [app-client] (ecmascript) <export default as bisector>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/throttle.js [app-client] (ecmascript) <export default as throttle>");
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
;
;
;
;
function maybeTransform(options) {
    const { transform = [] } = options;
    const normalizeY = transform.find((d)=>d.type === 'normalizeY');
    if (normalizeY) return normalizeY;
    const newNormalizeY = {
        type: 'normalizeY'
    };
    transform.push(newNormalizeY);
    options.transform = transform;
    return newNormalizeY;
}
function markValue(markState, markName, channels) {
    const [value] = Array.from(markState.entries()).filter(([mark])=>mark.type === markName).map(([mark])=>{
        const { encode } = mark;
        const channel = (name)=>{
            const channel = encode[name];
            return [
                name,
                channel ? channel.value : undefined
            ];
        };
        return Object.fromEntries(channels.map(channel));
    });
    return value;
}
function ChartIndex(_a) {
    var { wait = 20, leading, trailing = false, labelFormatter = (date)=>`${date}` } = _a, style = __rest(_a, [
        "wait",
        "leading",
        "trailing",
        "labelFormatter"
    ]);
    return (context)=>{
        const { view, container, update, setState } = context;
        const { markState, scale, coordinate } = view;
        // Get line mark value, exit if it is not existed.
        const value = markValue(markState, 'line', [
            'x',
            'y',
            'series'
        ]);
        if (!value) return;
        // Prepare channel value.
        const { y: Y, x: X, series: S = [] } = value;
        const I = Y.map((_, i)=>i);
        const sortedX = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sort$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__sort$3e$__["sort"])(I.map((i)=>X[i]));
        // Prepare shapes.
        const plotArea = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectPlotArea"])(container);
        const lines = container.getElementsByClassName(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ELEMENT_CLASS_NAME"]);
        const labels = container.getElementsByClassName(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LABEL_CLASS_NAME"]);
        // The format of label key: `${elementKey}-index`,
        // group labels by elementKey.
        const keyofLabel = (d)=>d.__data__.key.split('-')[0];
        const keyLabels = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__["group"])(labels, keyofLabel);
        const rule = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Line"]({
            style: Object.assign({
                x1: 0,
                y1: 0,
                x2: 0,
                y2: plotArea.getAttribute('height'),
                stroke: 'black',
                lineWidth: 1
            }, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'rule'))
        });
        const text = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"]({
            style: Object.assign({
                x: 0,
                y: plotArea.getAttribute('height'),
                text: '',
                fontSize: 10
            }, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'label'))
        });
        rule.append(text);
        plotArea.appendChild(rule);
        // Get the closet date to the rule.
        const dateByFocus = (coordinate, scaleX, focus)=>{
            const [normalizedX] = coordinate.invert(focus);
            const date = scaleX.invert(normalizedX);
            return sortedX[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bisectCenter"])(sortedX, date)];
        };
        // Update rule and label content.
        const updateRule = (focus, date)=>{
            rule.setAttribute('x1', focus[0]);
            rule.setAttribute('x2', focus[0]);
            text.setAttribute('text', labelFormatter(date));
        };
        // Store the new inner state alter rerender the view.
        let newView;
        // Rerender the view to update basis for each line.
        const updateBasisByRerender = (focus)=>__awaiter(this, void 0, void 0, function*() {
                // Find the closetDate to the rule.
                const { x: scaleX } = scale;
                const date = dateByFocus(coordinate, scaleX, focus);
                updateRule(focus, date);
                setState('chartIndex', (options)=>{
                    // Clone options and get line mark.
                    const clonedOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({}, options);
                    const lineMark = clonedOptions.marks.find((d)=>d.type === 'line');
                    // Update domain of y scale for the line mark.
                    const r = (I)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__["max"])(I, (i)=>+Y[i]) / (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__min$3e$__["min"])(I, (i)=>+Y[i]);
                    const k = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__max$3e$__["max"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rollup"])(I, r, (i)=>S[i]).values());
                    const domainY = [
                        1 / k,
                        k
                    ];
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])(lineMark, {
                        scale: {
                            y: {
                                domain: domainY
                            }
                        }
                    });
                    // Update normalize options.
                    const normalizeY = maybeTransform(lineMark);
                    normalizeY.groupBy = 'color';
                    normalizeY.basis = (I, Y)=>{
                        const i = I[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__bisector$3e$__["bisector"])((i)=>X[+i]).center(I, date)];
                        return Y[i];
                    };
                    // Disable animation.
                    for (const mark of clonedOptions.marks)mark.animate = false;
                    return clonedOptions;
                });
                const newState = yield update('chartIndex');
                newView = newState.view;
            });
        // Only apply translate to update basis for each line.
        // If performance is ok, there is no need to use this
        // strategy to update basis.
        const updateBasisByTranslate = (focus)=>{
            // Find the closetDate to the rule.
            const { scale, coordinate } = newView;
            const { x: scaleX, y: scaleY } = scale;
            const date = dateByFocus(coordinate, scaleX, focus);
            updateRule(focus, date);
            // Translate mark and label for better performance.
            for (const line of lines){
                // Compute transform in y direction.
                const { seriesIndex: SI, key } = line.__data__;
                const i = SI[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__bisector$3e$__["bisector"])((i)=>X[+i]).center(SI, date)];
                const p0 = [
                    0,
                    scaleY.map(1)
                ]; // basis point
                const p1 = [
                    0,
                    scaleY.map(Y[i] / Y[SI[0]])
                ];
                const [, y0] = coordinate.map(p0);
                const [, y1] = coordinate.map(p1);
                const dy = y0 - y1;
                line.setAttribute('transform', `translate(0, ${dy})`);
                // Update line and related label.
                const labels = keyLabels.get(key) || [];
                for (const label of labels){
                    // @todo Replace with style.transform.
                    // It now has unexpected behavior.
                    label.setAttribute('dy', dy);
                }
            }
        };
        const updateBasis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__["throttle"])((event)=>{
            const focus = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mousePosition"])(plotArea, event);
            if (!focus) return;
            updateBasisByTranslate(focus);
        }, wait, {
            leading,
            trailing
        });
        updateBasisByRerender([
            0,
            0
        ]);
        plotArea.addEventListener('pointerenter', updateBasis);
        plotArea.addEventListener('pointermove', updateBasis);
        plotArea.addEventListener('pointerleave', updateBasis);
        return ()=>{
            rule.remove();
            plotArea.removeEventListener('pointerenter', updateBasis);
            plotArea.removeEventListener('pointermove', updateBasis);
            plotArea.removeEventListener('pointerleave', updateBasis);
        };
    };
}
ChartIndex.props = {
    reapplyWhenUpdate: true
}; //# sourceMappingURL=chartIndex.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/event.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Event": (()=>Event),
    "dataOf": (()=>dataOf)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/event.js [app-client] (ecmascript)");
;
;
function dataOf(element, view) {
    const { __data__: datum } = element;
    const { markKey, index, seriesIndex } = datum;
    const { markState } = view;
    const selectedMark = Array.from(markState.keys()).find((mark)=>mark.key === markKey);
    if (!selectedMark) return;
    if (seriesIndex) {
        return seriesIndex.map((i)=>selectedMark.data[i]);
    }
    return selectedMark.data[index];
}
// For extended component
function maybeComponentRoot(node) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["maybeRoot"])(node, (node)=>node.className === 'component');
}
// For extended shape.
function maybeElementRoot(node) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["maybeRoot"])(node, (node)=>node.className === 'element');
}
// For extended label.
function maybeLabelRoot(node) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["maybeRoot"])(node, (node)=>node.className === 'label');
}
function bubblesEvent(eventType, view, emitter, predicate = (event)=>true) {
    return (e)=>{
        if (!predicate(e)) return;
        // Emit plot events.
        emitter.emit(`plot:${eventType}`, e);
        const { target } = e;
        // There is no target for pointerupoutside event if out of canvas.
        if (!target) return;
        const { className } = target;
        // If target area is plot area, do not emit extra events.
        if (className === 'plot') return;
        // If target is element or child of element.
        const elementRoot = maybeElementRoot(target);
        // If target is component or child of component.
        const componentRoot = maybeComponentRoot(target);
        //  If target is babel or child of babel.
        const babelRoot = maybeLabelRoot(target);
        const root = elementRoot || componentRoot || babelRoot;
        if (!root) return;
        const { className: elementType, markType } = root;
        const e1 = Object.assign(Object.assign({}, e), {
            nativeEvent: true
        });
        if (elementType === 'element') {
            e1['data'] = {
                data: dataOf(root, view)
            };
            emitter.emit(`element:${eventType}`, e1);
            emitter.emit(`${markType}:${eventType}`, e1);
        } else if (elementType === 'label') {
            //label children [Text2, Rect2, Path2],
            e1['data'] = {
                data: root.attributes.datum
            };
            emitter.emit(`label:${eventType}`, e1);
            emitter.emit(`${className}:${eventType}`, e1);
        } else {
            emitter.emit(`component:${eventType}`, e1);
            emitter.emit(`${className}:${eventType}`, e1);
        }
    };
}
function Event() {
    return (context, _, emitter)=>{
        const { container, view } = context;
        // Click events.
        const click = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].CLICK, view, emitter, (e)=>e.detail === 1);
        const dblclick = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].DBLCLICK, view, emitter, (e)=>e.detail === 2);
        // Pointer events.
        const pointertap = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].POINTER_TAP, view, emitter);
        const pointerdown = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].POINTER_DOWN, view, emitter);
        const pointerup = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].POINTER_UP, view, emitter);
        const pointerover = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].POINTER_OVER, view, emitter);
        const pointerout = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].POINTER_OUT, view, emitter);
        const pointermove = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].POINTER_MOVE, view, emitter);
        const pointerenter = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].POINTER_ENTER, view, emitter);
        const pointerleave = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].POINTER_LEAVE, view, emitter);
        const pointerupoutside = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].POINTER_UPOUTSIDE, view, emitter);
        // Drag and drop events.
        const dragstart = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].DRAG_START, view, emitter);
        const drag = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].DRAG, view, emitter);
        const dragend = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].DRAG_END, view, emitter);
        const dragenter = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].DRAG_ENTER, view, emitter);
        const dragleave = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].DRAG_LEAVE, view, emitter);
        const dragover = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].DRAG_OVER, view, emitter);
        const drop = bubblesEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChartEvent"].DROP, view, emitter);
        // For legacy usage.
        container.addEventListener('click', click);
        container.addEventListener('click', dblclick);
        // Recommend events.
        container.addEventListener('pointertap', pointertap);
        container.addEventListener('pointerdown', pointerdown);
        container.addEventListener('pointerup', pointerup);
        container.addEventListener('pointerover', pointerover);
        container.addEventListener('pointerout', pointerout);
        container.addEventListener('pointermove', pointermove);
        container.addEventListener('pointerenter', pointerenter);
        container.addEventListener('pointerleave', pointerleave);
        container.addEventListener('pointerupoutside', pointerupoutside);
        // Plugin events.
        container.addEventListener('dragstart', dragstart);
        container.addEventListener('drag', drag);
        container.addEventListener('dragend', dragend);
        container.addEventListener('dragenter', dragenter);
        container.addEventListener('dragleave', dragleave);
        container.addEventListener('dragover', dragover);
        container.addEventListener('drop', drop);
        return ()=>{
            container.removeEventListener('click', click);
            container.removeEventListener('click', dblclick);
            container.removeEventListener('pointertap', pointertap);
            container.removeEventListener('pointerdown', pointerdown);
            container.removeEventListener('pointerup', pointerup);
            container.removeEventListener('pointerover', pointerover);
            container.removeEventListener('pointerout', pointerout);
            container.removeEventListener('pointermove', pointermove);
            container.removeEventListener('pointerenter', pointerenter);
            container.removeEventListener('pointerleave', pointerleave);
            container.removeEventListener('pointerupoutside', pointerupoutside);
            container.removeEventListener('dragstart', dragstart);
            container.removeEventListener('drag', drag);
            container.removeEventListener('dragend', dragend);
            container.removeEventListener('dragenter', dragenter);
            container.removeEventListener('dragleave', dragleave);
            container.removeEventListener('dragover', dragover);
            container.removeEventListener('drop', drop);
        };
    };
}
Event.props = {
    reapplyWhenUpdate: true
}; //# sourceMappingURL=event.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/tooltip.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Tooltip": (()=>Tooltip),
    "seriesTooltip": (()=>seriesTooltip),
    "tooltip": (()=>tooltip)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/g/dist/index.esm.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$component$2f$esm$2f$ui$2f$tooltip$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/component/esm/ui/tooltip/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/deep-mix.js [app-client] (ecmascript) <export default as deepMix>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$scale$2f$esm$2f$scales$2f$band$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/scale/esm/scales/band.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$scale$2f$esm$2f$scales$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/scale/esm/scales/constant.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g-lite/dist/index.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$minIndex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__minIndex$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/minIndex.js [app-client] (ecmascript) <export default as minIndex>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$mean$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__mean$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/mean.js [app-client] (ecmascript) <export default as mean>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/coordinate.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sort$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__sort$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/sort.js [app-client] (ecmascript) <export default as sort>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__bisector$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/bisector.js [app-client] (ecmascript) <export default as bisector>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/group.js [app-client] (ecmascript) <export default as group>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$lower$2d$first$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__lowerFirst$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/lower-first.js [app-client] (ecmascript) <export default as lowerFirst>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/throttle.js [app-client] (ecmascript) <export default as throttle>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/scale.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/event.js [app-client] (ecmascript)");
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
;
;
;
;
;
;
;
;
;
function getContainer(group, mount) {
    if (mount) {
        return typeof mount === 'string' ? document.querySelector(mount) : mount;
    }
    const canvas = group.ownerDocument.defaultView.getContextService().getDomElement();
    return canvas.parentElement;
}
function getBounding(root) {
    const bbox = root.getRenderBounds();
    const { min: [x1, y1], max: [x2, y2] } = bbox;
    return {
        x: x1,
        y: y1,
        width: x2 - x1,
        height: y2 - y1
    };
}
function getContainerOffset(container1, container2) {
    const r1 = container1.getBoundingClientRect();
    const r2 = container2.getBoundingClientRect();
    return {
        x: r1.x - r2.x,
        y: r1.y - r2.y
    };
}
function createTooltip(container, x0, y0, position, enterable, bounding, containerOffset, css = {}, offset = [
    10,
    10
]) {
    const defaults = {
        '.g2-tooltip': {},
        '.g2-tooltip-title': {
            overflow: 'hidden',
            'white-space': 'nowrap',
            'text-overflow': 'ellipsis'
        }
    };
    const tooltipElement = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$component$2f$esm$2f$ui$2f$tooltip$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tooltip"]({
        className: 'tooltip',
        style: {
            x: x0,
            y: y0,
            container: containerOffset,
            data: [],
            bounding,
            position,
            enterable,
            title: '',
            offset,
            template: {
                prefixCls: 'g2-'
            },
            style: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])(defaults, css)
        }
    });
    container.appendChild(tooltipElement.HTMLTooltipElement);
    return tooltipElement;
}
function showTooltip({ root, data, x, y, render, event, single, position = 'right-bottom', enterable = false, css, mount, bounding, offset }) {
    const container = getContainer(root, mount);
    const canvasContainer = getContainer(root);
    // All the views share the same tooltip.
    const parent = single ? canvasContainer : root;
    const b = bounding || getBounding(root);
    const containerOffset = getContainerOffset(canvasContainer, container);
    const { tooltipElement = createTooltip(container, x, y, position, enterable, b, containerOffset, css, offset) } = parent;
    const { items, title = '' } = data;
    tooltipElement.update(Object.assign({
        x,
        y,
        data: items,
        title,
        position,
        enterable,
        container: containerOffset
    }, render !== undefined && {
        content: render(event, {
            items,
            title
        })
    }));
    parent.tooltipElement = tooltipElement;
}
function hideTooltip({ root, single, emitter, nativeEvent = true, event = null }) {
    if (nativeEvent) {
        emitter.emit('tooltip:hide', {
            nativeEvent
        });
    }
    const container = getContainer(root);
    const parent = single ? container : root;
    const { tooltipElement } = parent;
    if (tooltipElement) {
        // Must be clientX, clientY.
        tooltipElement.hide(event === null || event === void 0 ? void 0 : event.clientX, event === null || event === void 0 ? void 0 : event.clientY);
    }
    hideRuleY(root);
    hideRuleX(root);
    hideMarker(root);
}
function destroyTooltip({ root, single }) {
    const container = getContainer(root);
    const parent = single ? container : root;
    if (!parent) return;
    const { tooltipElement } = parent;
    if (tooltipElement) {
        tooltipElement.destroy();
        parent.tooltipElement = undefined;
    }
    hideRuleY(root);
    hideRuleX(root);
    hideMarker(root);
}
function showUndefined(item) {
    const { value } = item;
    return Object.assign(Object.assign({}, item), {
        value: value === undefined ? 'undefined' : value
    });
}
function singleItem(element) {
    const { __data__: datum } = element;
    const { title, items = [] } = datum;
    const newItems = items.filter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]).map((_a)=>{
        var { color = itemColorOf(element) } = _a, item = __rest(_a, [
            "color"
        ]);
        return Object.assign(Object.assign({}, item), {
            color
        });
    }).map(showUndefined);
    return Object.assign(Object.assign({}, title && {
        title
    }), {
        items: newItems
    });
}
function groupNameOf(scale, datum) {
    const { color: scaleColor, series: scaleSeries, facet = false } = scale;
    const { color, series } = datum;
    const invertAble = (scale)=>{
        return scale && scale.invert && !(scale instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$scale$2f$esm$2f$scales$2f$band$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Band"]) && !(scale instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$scale$2f$esm$2f$scales$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Constant"]);
    };
    // For non constant color channel.
    if (invertAble(scaleSeries)) {
        const cloned = scaleSeries.clone();
        return cloned.invert(series);
    }
    if (series && scaleSeries instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$scale$2f$esm$2f$scales$2f$band$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Band"] && scaleSeries.invert(series) !== color && !facet) {
        return scaleSeries.invert(series);
    }
    if (invertAble(scaleColor)) {
        const name = scaleColor.invert(color);
        // For threshold scale.
        if (Array.isArray(name)) return null;
        return name;
    }
    return null;
}
function itemColorOf(element) {
    const fill = element.getAttribute('fill');
    const stroke = element.getAttribute('stroke');
    const { __data__: datum } = element;
    const { color = fill && fill !== 'transparent' ? fill : stroke } = datum;
    return color;
}
function unique(items, key = (d)=>d) {
    const valueName = new Map(items.map((d)=>[
            key(d),
            d
        ]));
    return Array.from(valueName.values());
}
function groupItems(elements, scale, groupName, data = elements.map((d)=>d['__data__']), theme = {}) {
    const key = (d)=>d instanceof Date ? +d : d;
    const T = unique(data.map((d)=>d.title), key).filter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]);
    const newItems = data.flatMap((datum, i)=>{
        const element = elements[i];
        const { items = [], title } = datum;
        const definedItems = items.filter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]);
        // If there is only one item, use groupName as title by default.
        const useGroupName = groupName !== undefined ? groupName : items.length <= 1 ? true : false;
        return definedItems.map((_a)=>{
            var { color = itemColorOf(element) || theme.color, name } = _a, item = __rest(_a, [
                "color",
                "name"
            ]);
            const groupName = groupNameOf(scale, datum);
            const name1 = useGroupName ? groupName || name : name || groupName;
            return Object.assign(Object.assign({}, item), {
                color,
                name: name1 || title
            });
        });
    }).map(showUndefined);
    return Object.assign(Object.assign({}, T.length > 0 && {
        title: T.join(',')
    }), {
        items: unique(newItems, (d)=>`(${key(d.name)}, ${key(d.value)}, ${key(d.color)})`)
    });
}
function updateRuleX(root, points, mouse, _a) {
    var { plotWidth, plotHeight, mainWidth, mainHeight, startX, startY, transposed, polar, insetLeft, insetTop } = _a, rest = __rest(_a, [
        "plotWidth",
        "plotHeight",
        "mainWidth",
        "mainHeight",
        "startX",
        "startY",
        "transposed",
        "polar",
        "insetLeft",
        "insetTop"
    ]);
    const defaults = Object.assign({
        lineWidth: 1,
        stroke: '#1b1e23',
        strokeOpacity: 0.5
    }, rest);
    const createCircle = (cx, cy, r)=>{
        const circle = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Circle"]({
            style: Object.assign({
                cx,
                cy,
                r
            }, defaults)
        });
        root.appendChild(circle);
        return circle;
    };
    const createLine = (x1, x2, y1, y2)=>{
        const line = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Line"]({
            style: Object.assign({
                x1,
                x2,
                y1,
                y2
            }, defaults)
        });
        root.appendChild(line);
        return line;
    };
    const minDistPoint = (mouse, points)=>{
        // only one point do not need compute
        if (points.length === 1) {
            return points[0];
        }
        const dists = points.map((p)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dist"])(p, mouse));
        const minDistIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$minIndex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__minIndex$3e$__["minIndex"])(dists, (d)=>d);
        return points[minDistIndex];
    };
    const target = minDistPoint(mouse, points);
    const pointsOf = ()=>{
        if (transposed) return [
            startX + target[0],
            startX + target[0],
            startY,
            startY + plotHeight
        ];
        return [
            startX,
            startX + plotWidth,
            target[1] + startY,
            target[1] + startY
        ];
    };
    const pointsOfPolar = ()=>{
        const cx = startX + insetLeft + mainWidth / 2;
        const cy = startY + insetTop + mainHeight / 2;
        const cdist = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dist"])([
            cx,
            cy
        ], target);
        return [
            cx,
            cy,
            cdist
        ];
    };
    if (polar) {
        const [cx, cy, r] = pointsOfPolar();
        const ruleX = root.ruleX || createCircle(cx, cy, r);
        ruleX.style.cx = cx;
        ruleX.style.cy = cy;
        ruleX.style.r = r;
        root.ruleX = ruleX;
    } else {
        const [x1, x2, y1, y2] = pointsOf();
        const ruleX = root.ruleX || createLine(x1, x2, y1, y2);
        ruleX.style.x1 = x1;
        ruleX.style.x2 = x2;
        ruleX.style.y1 = y1;
        ruleX.style.y2 = y2;
        root.ruleX = ruleX;
    }
}
function updateRuleY(root, points, _a) {
    var { plotWidth, plotHeight, mainWidth, mainHeight, startX, startY, transposed, polar, insetLeft, insetTop } = _a, rest = __rest(_a, [
        "plotWidth",
        "plotHeight",
        "mainWidth",
        "mainHeight",
        "startX",
        "startY",
        "transposed",
        "polar",
        "insetLeft",
        "insetTop"
    ]);
    const defaults = Object.assign({
        lineWidth: 1,
        stroke: '#1b1e23',
        strokeOpacity: 0.5
    }, rest);
    const Y = points.map((p)=>p[1]);
    const X = points.map((p)=>p[0]);
    const y = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$mean$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__mean$3e$__["mean"])(Y);
    const x = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$mean$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__mean$3e$__["mean"])(X);
    const pointsOf = ()=>{
        if (polar) {
            const r = Math.min(mainWidth, mainHeight) / 2;
            const cx = startX + insetLeft + mainWidth / 2;
            const cy = startY + insetTop + mainHeight / 2;
            const a = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["angle"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sub"])([
                x,
                y
            ], [
                cx,
                cy
            ]));
            const x0 = cx + r * Math.cos(a);
            const y0 = cy + r * Math.sin(a);
            return [
                cx,
                x0,
                cy,
                y0
            ];
        }
        if (transposed) return [
            startX,
            startX + plotWidth,
            y + startY,
            y + startY
        ];
        return [
            x + startX,
            x + startX,
            startY,
            startY + plotHeight
        ];
    };
    const [x1, x2, y1, y2] = pointsOf();
    const createLine = ()=>{
        const line = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Line"]({
            style: Object.assign({
                x1,
                x2,
                y1,
                y2
            }, defaults)
        });
        root.appendChild(line);
        return line;
    };
    // Only update rule with defined series elements.
    if (X.length > 0) {
        const ruleY = root.ruleY || createLine();
        ruleY.style.x1 = x1;
        ruleY.style.x2 = x2;
        ruleY.style.y1 = y1;
        ruleY.style.y2 = y2;
        root.ruleY = ruleY;
    }
}
function hideRuleY(root) {
    if (root.ruleY) {
        root.ruleY.remove();
        root.ruleY = undefined;
    }
}
function hideRuleX(root) {
    if (root.ruleX) {
        root.ruleX.remove();
        root.ruleX = undefined;
    }
}
function updateMarker(root, { data, style, theme }) {
    if (root.markers) root.markers.forEach((d)=>d.remove());
    const { type = '' } = style;
    const markers = data.filter((d)=>{
        const [{ x, y }] = d;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"])(x) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"])(y);
    }).map((d)=>{
        const [{ color, element }, point] = d;
        const originColor = color || // encode value
        element.style.fill || element.style.stroke || theme.color;
        const fill = type === 'hollow' ? 'transparent' : originColor;
        const stroke = type === 'hollow' ? originColor : '#fff';
        const shape = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Circle"]({
            className: 'g2-tooltip-marker',
            style: Object.assign({
                cx: point[0],
                cy: point[1],
                fill,
                r: 4,
                stroke,
                lineWidth: 2
            }, style)
        });
        return shape;
    });
    for (const marker of markers)root.appendChild(marker);
    root.markers = markers;
}
function hideMarker(root) {
    if (root.markers) {
        root.markers.forEach((d)=>d.remove());
        root.markers = [];
    }
}
function interactionKeyof(markState, key) {
    return Array.from(markState.values()).some(// @ts-ignore
    (d)=>{
        var _a;
        return (_a = d.interaction) === null || _a === void 0 ? void 0 : _a[key];
    });
}
function maybeValue(specified, defaults) {
    return specified === undefined ? defaults : specified;
}
function isEmptyTooltipData(data) {
    const { title, items } = data;
    if (items.length === 0 && title === undefined) return true;
    return false;
}
function hasSeries(markState) {
    return Array.from(markState.values()).some(// @ts-ignore
    (d)=>{
        var _a;
        return ((_a = d.interaction) === null || _a === void 0 ? void 0 : _a.seriesTooltip) && d.tooltip;
    });
}
function seriesTooltip(root, _a) {
    var { elements: elementsof, sort: sortFunction, filter: filterFunction, scale, coordinate, crosshairs, crosshairsX, crosshairsY, render, groupName, emitter, wait = 50, leading = true, trailing = false, startX = 0, startY = 0, body = true, single = true, position, enterable, mount, bounding, theme, offset, disableNative = false, marker = true, preserve = false, style: _style = {}, css = {} } = _a, rest = __rest(_a, [
        "elements",
        "sort",
        "filter",
        "scale",
        "coordinate",
        "crosshairs",
        "crosshairsX",
        "crosshairsY",
        "render",
        "groupName",
        "emitter",
        "wait",
        "leading",
        "trailing",
        "startX",
        "startY",
        "body",
        "single",
        "position",
        "enterable",
        "mount",
        "bounding",
        "theme",
        "offset",
        "disableNative",
        "marker",
        "preserve",
        "style",
        "css"
    ]);
    const elements = elementsof(root);
    const transposed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTranspose"])(coordinate);
    const polar = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPolar"])(coordinate);
    const style = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])(_style, rest);
    const { innerWidth: plotWidth, innerHeight: plotHeight, width: mainWidth, height: mainHeight, insetLeft, insetTop } = coordinate.getOptions();
    // Split elements into series elements and item elements.
    const seriesElements = [];
    const itemElements = [];
    for (const element of elements){
        const { __data__: data } = element;
        const { seriesX, title, items } = data;
        if (seriesX) seriesElements.push(element);
        else if (title || items) itemElements.push(element);
    }
    const inInterval = (d)=>d.markType === 'interval';
    const isBar = itemElements.length && itemElements.every(inInterval) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPolar"])(coordinate);
    const xof = (d)=>d.__data__.x;
    // For band scale x, find the closest series element to focus,
    // useful for interval + line mark.
    const isBandScale = !!scale.x.getBandWidth;
    const closest = isBandScale && itemElements.length > 0;
    // Sorted elements from top to bottom visually,
    // or from right to left in transpose coordinate.
    seriesElements.sort((a, b)=>{
        const index = transposed ? 0 : 1;
        const minY = (d)=>d.getBounds().min[index];
        return transposed ? minY(b) - minY(a) : minY(a) - minY(b);
    });
    const extent = (d)=>{
        const index = transposed ? 1 : 0;
        const { min, max } = d.getLocalBounds();
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sort$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__sort$3e$__["sort"])([
            min[index],
            max[index]
        ]);
    };
    // Sort itemElements for bisector search.
    if (isBar) elements.sort((a, b)=>xof(a) - xof(b));
    else {
        itemElements.sort((a, b)=>{
            const [minA, maxA] = extent(a);
            const [minB, maxB] = extent(b);
            const midA = (minA + maxA) / 2;
            const midB = (minB + maxB) / 2;
            return transposed ? midB - midA : midA - midB;
        });
    }
    // Get sortedIndex and X for each series elements
    const elementSortedX = new Map(seriesElements.map((element)=>{
        const { __data__: data } = element;
        const { seriesX } = data;
        const seriesIndex = seriesX.map((_, i)=>i);
        const sortedIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sort$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__sort$3e$__["sort"])(seriesIndex, (i)=>seriesX[+i]);
        return [
            element,
            [
                sortedIndex,
                seriesX
            ]
        ];
    }));
    const { x: scaleX } = scale;
    // Apply offset for band scale x.
    const offsetX = (scaleX === null || scaleX === void 0 ? void 0 : scaleX.getBandWidth) ? scaleX.getBandWidth() / 2 : 0;
    const abstractX = (focus)=>{
        const [normalizedX] = coordinate.invert(focus);
        return normalizedX - offsetX;
    };
    const indexByFocus = (event, focus, I, X)=>{
        // _x is from emit event, to find the right element.
        const { _x } = event;
        const finalX = _x !== undefined ? scaleX.map(_x) : abstractX(focus);
        const DX = X.filter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]);
        const [minX, maxX] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sort$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__sort$3e$__["sort"])([
            DX[0],
            DX[DX.length - 1]
        ]);
        // If only has one element(minX == maxX), show tooltip when hover whole chart
        const isOnlyOneElement = minX === maxX;
        // If closest is true, always find at least one element.
        // Otherwise, skip element out of plot area.
        if (!closest && (finalX < minX || finalX > maxX) && !isOnlyOneElement) return null;
        const search = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__bisector$3e$__["bisector"])((i)=>X[+i]).center;
        const i = search(I, finalX);
        return I[i];
    };
    const elementsByFocus = isBar ? (focus, elements)=>{
        const search = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__bisector$3e$__["bisector"])(xof).center;
        const i = search(elements, abstractX(focus));
        const find = elements[i];
        const groups = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__["group"])(elements, xof);
        const selected = groups.get(xof(find));
        return selected;
    } : (focus, elements)=>{
        const index = transposed ? 1 : 0;
        const x = focus[index];
        const filtered = elements.filter((element)=>{
            const [min, max] = extent(element);
            return x >= min && x <= max;
        });
        // If closet is true, always find at least one element.
        if (!closest || filtered.length > 0) return filtered;
        // Search the closet element to the focus.
        const search = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__bisector$3e$__["bisector"])((element)=>{
            const [min, max] = extent(element);
            return (min + max) / 2;
        }).center;
        const i = search(elements, x);
        return [
            elements[i]
        ].filter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]);
    };
    const seriesData = (element, index)=>{
        const { __data__: data } = element;
        return Object.fromEntries(Object.entries(data).filter(([key])=>key.startsWith('series') && key !== 'series').map(([key, V])=>{
            const d = V[index];
            return [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$lower$2d$first$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__lowerFirst$3e$__["lowerFirst"])(key.replace('series', '')),
                d
            ];
        }));
    };
    const update = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__["throttle"])((event)=>{
        var _a;
        const mouse = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mousePosition"])(root, event);
        if (!mouse) return;
        const bbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bboxOf"])(root);
        const x = bbox.min[0];
        const y = bbox.min[1];
        const focus = [
            mouse[0] - startX,
            mouse[1] - startY
        ];
        if ("TURBOPACK compile-time falsy", 0) {
            "TURBOPACK unreachable";
        }
        // Get selected item element.
        const selectedItems = elementsByFocus(focus, itemElements);
        // Get selected data item from both series element and item element.
        const selectedSeriesElements = [];
        const selectedSeriesData = [];
        for (const element of seriesElements){
            const [sortedIndex, X] = elementSortedX.get(element);
            const index = indexByFocus(event, focus, sortedIndex, X);
            if (index !== null) {
                selectedSeriesElements.push(element);
                const d = seriesData(element, index);
                const { x, y } = d;
                const p = coordinate.map([
                    (x || 0) + offsetX,
                    y || 0
                ]);
                selectedSeriesData.push([
                    Object.assign(Object.assign({}, d), {
                        element
                    }),
                    p
                ]);
            }
        }
        // Filter selectedSeriesData with different x,
        // make sure there is only one x closest to focusX.
        const SX = Array.from(new Set(selectedSeriesData.map((d)=>d[0].x)));
        const closestX = SX[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$minIndex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__minIndex$3e$__["minIndex"])(SX, (x)=>Math.abs(x - abstractX(focus)))];
        const filteredSeriesData = selectedSeriesData.filter((d)=>d[0].x === closestX);
        const selectedData = [
            ...filteredSeriesData.map((d)=>d[0]),
            ...selectedItems.map((d)=>d.__data__)
        ];
        // Get the displayed tooltip data.
        const selectedElements = [
            ...selectedSeriesElements,
            ...selectedItems
        ];
        const tooltipData = groupItems(selectedElements, scale, groupName, selectedData, theme);
        // Sort items and filter items.
        if (sortFunction) {
            tooltipData.items.sort((a, b)=>sortFunction(a) - sortFunction(b));
        }
        if (filterFunction) {
            tooltipData.items = tooltipData.items.filter(filterFunction);
        }
        // Hide tooltip with no selected tooltip.
        if (selectedElements.length === 0 || isEmptyTooltipData(tooltipData)) {
            hide(event);
            return;
        }
        if (body) {
            showTooltip({
                root,
                data: tooltipData,
                x: mouse[0] + x,
                y: mouse[1] + y,
                render,
                event,
                single,
                position,
                enterable,
                mount,
                bounding,
                css,
                offset
            });
        }
        if (crosshairs || crosshairsX || crosshairsY) {
            const ruleStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'crosshairs');
            const ruleStyleX = Object.assign(Object.assign({}, ruleStyle), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'crosshairsX'));
            const ruleStyleY = Object.assign(Object.assign({}, ruleStyle), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'crosshairsY'));
            const points = filteredSeriesData.map((d)=>d[1]);
            if (crosshairsX) {
                updateRuleX(root, points, mouse, Object.assign(Object.assign({}, ruleStyleX), {
                    plotWidth,
                    plotHeight,
                    mainWidth,
                    mainHeight,
                    insetLeft,
                    insetTop,
                    startX,
                    startY,
                    transposed,
                    polar
                }));
            }
            if (crosshairsY) {
                updateRuleY(root, points, Object.assign(Object.assign({}, ruleStyleY), {
                    plotWidth,
                    plotHeight,
                    mainWidth,
                    mainHeight,
                    insetLeft,
                    insetTop,
                    startX,
                    startY,
                    transposed,
                    polar
                }));
            }
        }
        if (marker) {
            const markerStyles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'marker');
            updateMarker(root, {
                data: filteredSeriesData,
                style: markerStyles,
                theme
            });
        }
        // X in focus may related multiple points when dataset is large,
        // so we need to find the first x to show tooltip.
        const firstX = (_a = filteredSeriesData[0]) === null || _a === void 0 ? void 0 : _a[0].x;
        const transformedX = firstX !== null && firstX !== void 0 ? firstX : abstractX(focus);
        emitter.emit('tooltip:show', Object.assign(Object.assign({}, event), {
            nativeEvent: true,
            data: Object.assign(Object.assign({}, tooltipData), {
                data: {
                    x: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["invert"])(scale.x, transformedX, true)
                }
            })
        }));
    }, wait, {
        leading,
        trailing
    });
    const hide = (event)=>{
        hideTooltip({
            root,
            single,
            emitter,
            event
        });
    };
    const destroy = ()=>{
        destroyTooltip({
            root,
            single
        });
    };
    const onTooltipShow = (_a)=>{
        var _b;
        var { nativeEvent, data, offsetX, offsetY } = _a, rest = __rest(_a, [
            "nativeEvent",
            "data",
            "offsetX",
            "offsetY"
        ]);
        if (nativeEvent) return;
        const x = (_b = data === null || data === void 0 ? void 0 : data.data) === null || _b === void 0 ? void 0 : _b.x;
        const scaleX = scale.x;
        const x1 = scaleX.map(x);
        const [x2, y2] = coordinate.map([
            x1,
            0.5
        ]);
        const rootBounds = root.getRenderBounds();
        const minX = rootBounds.min[0];
        const minY = rootBounds.min[1];
        update(Object.assign(Object.assign({}, rest), {
            offsetX: offsetX !== undefined ? offsetX : minX + x2,
            offsetY: offsetY !== undefined ? offsetY : minY + y2,
            _x: x
        }));
    };
    const onTooltipHide = ()=>{
        hideTooltip({
            root,
            single,
            emitter,
            nativeEvent: false
        });
    };
    const onTooltipDisable = ()=>{
        removeEventListeners();
        destroy();
    };
    const onTooltipEnable = ()=>{
        addEventListeners();
    };
    const addEventListeners = ()=>{
        if (!disableNative) {
            root.addEventListener('pointerenter', update);
            root.addEventListener('pointermove', update);
            // Only emit pointerleave event when the pointer is not in the root area.
            root.addEventListener('pointerleave', (e)=>{
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mousePosition"])(root, e)) return;
                hide(e);
            });
        }
    };
    const removeEventListeners = ()=>{
        if (!disableNative) {
            root.removeEventListener('pointerenter', update);
            root.removeEventListener('pointermove', update);
            root.removeEventListener('pointerleave', hide);
        }
    };
    addEventListeners();
    emitter.on('tooltip:show', onTooltipShow);
    emitter.on('tooltip:hide', onTooltipHide);
    emitter.on('tooltip:disable', onTooltipDisable);
    emitter.on('tooltip:enable', onTooltipEnable);
    return ()=>{
        removeEventListeners();
        emitter.off('tooltip:show', onTooltipShow);
        emitter.off('tooltip:hide', onTooltipHide);
        emitter.off('tooltip:disable', onTooltipDisable);
        emitter.off('tooltip:enable', onTooltipEnable);
        if (preserve) {
            hideTooltip({
                root,
                single,
                emitter,
                nativeEvent: false
            });
        } else {
            destroy();
        }
    };
}
function tooltip(root, { elements: elementsof, coordinate, scale, render, groupName, sort: sortFunction, filter: filterFunction, emitter, wait = 50, leading = true, trailing = false, groupKey = (d)=>d, single = true, position, enterable, datum, view, mount, bounding, theme, offset, shared = false, body = true, disableNative = false, preserve = false, css = {} }) {
    var _a, _b;
    const elements = elementsof(root);
    const keyGroup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__["group"])(elements, groupKey);
    const inInterval = (d)=>d.markType === 'interval';
    const isBar = elements.every(inInterval) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPolar"])(coordinate);
    const scaleX = scale.x;
    const scaleSeries = scale.series;
    const bandWidth = (_b = (_a = scaleX === null || scaleX === void 0 ? void 0 : scaleX.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(scaleX)) !== null && _b !== void 0 ? _b : 0;
    const xof = scaleSeries ? (d)=>{
        const seriesCount = Math.round(1 / scaleSeries.valueBandWidth);
        return d.__data__.x + d.__data__.series * bandWidth + bandWidth / (seriesCount * 2);
    } : (d)=>d.__data__.x + bandWidth / 2;
    // Sort for bisector search.
    if (isBar) elements.sort((a, b)=>xof(a) - xof(b));
    const findElementByTarget = (event)=>{
        const { target } = event;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["maybeRoot"])(target, (node)=>{
            if (!node.classList) return false;
            return node.classList.includes('element');
        });
    };
    const findElement = isBar ? (event)=>{
        const mouse = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mousePosition"])(root, event);
        if (!mouse) return;
        const [abstractX] = coordinate.invert(mouse);
        const search = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__bisector$3e$__["bisector"])(xof).center;
        const i = search(elements, abstractX);
        const target = elements[i];
        if (!shared) {
            // For grouped bar chart without shared options.
            const isGrouped = elements.find((d)=>d !== target && xof(d) === xof(target));
            if (isGrouped) return findElementByTarget(event);
        }
        return target;
    } : findElementByTarget;
    const pointermove = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__["throttle"])((event)=>{
        const element = findElement(event);
        if (!element) {
            hideTooltip({
                root,
                single,
                emitter,
                event
            });
            return;
        }
        const k = groupKey(element);
        const group = keyGroup.get(k);
        if (!group) {
            return;
        }
        const data = group.length === 1 && !shared ? singleItem(group[0]) : groupItems(group, scale, groupName, undefined, theme);
        // Sort items and sort.
        if (sortFunction) {
            data.items.sort((a, b)=>sortFunction(a) - sortFunction(b));
        }
        if (filterFunction) {
            data.items = data.items.filter(filterFunction);
        }
        if (isEmptyTooltipData(data)) {
            hideTooltip({
                root,
                single,
                emitter,
                event
            });
            return;
        }
        const { offsetX, offsetY } = event;
        if (body) {
            showTooltip({
                root,
                data,
                x: offsetX,
                y: offsetY,
                render,
                event,
                single,
                position,
                enterable,
                mount,
                bounding,
                css,
                offset
            });
        }
        emitter.emit('tooltip:show', Object.assign(Object.assign({}, event), {
            nativeEvent: true,
            data: Object.assign(Object.assign({}, data), {
                data: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dataOf"])(element, view)
            })
        }));
    }, wait, {
        leading,
        trailing
    });
    const pointerleave = (event)=>{
        hideTooltip({
            root,
            single,
            emitter,
            event
        });
    };
    const addEventListeners = ()=>{
        if (!disableNative) {
            root.addEventListener('pointermove', pointermove);
            // Only emit pointerleave event when the pointer is not in the root area.
            // !!!DO NOT USE pointerout event, it will emit when the pointer is in the child area.
            root.addEventListener('pointerleave', pointerleave);
        }
    };
    const removeEventListeners = ()=>{
        if (!disableNative) {
            root.removeEventListener('pointermove', pointermove);
            root.removeEventListener('pointerleave', pointerleave);
        }
    };
    const onTooltipShow = ({ nativeEvent, offsetX, offsetY, data: raw })=>{
        if (nativeEvent) return;
        const { data } = raw;
        const element = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectElementByData"])(elements, data, datum);
        if (!element) return;
        const bbox = element.getBBox();
        const { x, y, width, height } = bbox;
        const rootBBox = root.getBBox();
        pointermove({
            target: element,
            offsetX: offsetX !== undefined ? offsetX + rootBBox.x : x + width / 2,
            offsetY: offsetY !== undefined ? offsetY + rootBBox.y : y + height / 2
        });
    };
    const onTooltipHide = ({ nativeEvent } = {})=>{
        if (nativeEvent) return;
        hideTooltip({
            root,
            single,
            emitter,
            nativeEvent: false
        });
    };
    const onTooltipDisable = ()=>{
        removeEventListeners();
        destroyTooltip({
            root,
            single
        });
    };
    const onTooltipEnable = ()=>{
        addEventListeners();
    };
    emitter.on('tooltip:show', onTooltipShow);
    emitter.on('tooltip:hide', onTooltipHide);
    emitter.on('tooltip:enable', onTooltipEnable);
    emitter.on('tooltip:disable', onTooltipDisable);
    addEventListeners();
    return ()=>{
        removeEventListeners();
        emitter.off('tooltip:show', onTooltipShow);
        emitter.off('tooltip:hide', onTooltipHide);
        if (preserve) {
            hideTooltip({
                root,
                single,
                emitter,
                nativeEvent: false
            });
        } else {
            destroyTooltip({
                root,
                single
            });
        }
    };
}
function Tooltip(options) {
    const { shared, crosshairs, crosshairsX, crosshairsY, series, name, item = ()=>({}), facet = false } = options, rest = __rest(options, [
        "shared",
        "crosshairs",
        "crosshairsX",
        "crosshairsY",
        "series",
        "name",
        "item",
        "facet"
    ]);
    return (target, viewInstances, emitter)=>{
        const { container, view } = target;
        const { scale, markState, coordinate, theme } = view;
        // Get default value from mark states.
        const defaultSeries = interactionKeyof(markState, 'seriesTooltip');
        const defaultShowCrosshairs = interactionKeyof(markState, 'crosshairs');
        const plotArea = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectPlotArea"])(container);
        const isSeries = maybeValue(series, defaultSeries);
        const crosshairsSetting = maybeValue(crosshairs, defaultShowCrosshairs);
        // For non-facet and series tooltip.
        if (isSeries && hasSeries(markState) && !facet) {
            return seriesTooltip(plotArea, Object.assign(Object.assign({}, rest), {
                theme,
                elements: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectG2Elements"],
                scale,
                coordinate,
                crosshairs: crosshairsSetting,
                // the crosshairsX settings level: crosshairsX > crosshairs > false
                // it means crosshairsX default is false
                crosshairsX: maybeValue(maybeValue(crosshairsX, crosshairs), false),
                // crosshairsY default depend on the crossharisSettings
                crosshairsY: maybeValue(crosshairsY, crosshairsSetting),
                item,
                emitter
            }));
        }
        // For facet and series tooltip.
        if (isSeries && facet) {
            // Get sub view instances for this view.
            const facetInstances = viewInstances.filter((d)=>d !== target && d.options.parentKey === target.options.key);
            const elements = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectFacetG2Elements"])(target, viewInstances);
            // Use the scale of the first view.
            const scale = facetInstances[0].view.scale;
            const bbox = plotArea.getBounds();
            const startX = bbox.min[0];
            const startY = bbox.min[1];
            Object.assign(scale, {
                facet: true
            });
            // @todo Nested structure rather than flat structure for facet?
            // Add listener to the root area.
            // @ts-ignore
            return seriesTooltip(plotArea.parentNode.parentNode, Object.assign(Object.assign({}, rest), {
                theme,
                elements: ()=>elements,
                scale,
                coordinate,
                crosshairs: maybeValue(crosshairs, defaultShowCrosshairs),
                // the crosshairsX settings level: crosshairsX > crosshairs > false
                // it means crosshairsX default is false
                crosshairsX: maybeValue(maybeValue(crosshairsX, crosshairs), false),
                crosshairsY: maybeValue(crosshairsY, crosshairsSetting),
                item,
                startX,
                startY,
                emitter
            }));
        }
        return tooltip(plotArea, Object.assign(Object.assign({}, rest), {
            datum: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDatumof"])(view),
            elements: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectG2Elements"],
            scale,
            coordinate,
            groupKey: shared ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createXKey"])(view) : undefined,
            item,
            emitter,
            view,
            theme,
            shared
        }));
    };
}
Tooltip.props = {
    reapplyWhenUpdate: true
}; //# sourceMappingURL=tooltip.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/legendFilter.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "CATEGORY_LEGEND_CLASS_NAME": (()=>CATEGORY_LEGEND_CLASS_NAME),
    "CONTINUOUS_LEGEND_CLASS_NAME": (()=>CONTINUOUS_LEGEND_CLASS_NAME),
    "LEGEND_ITEMS_CLASS_NAME": (()=>LEGEND_ITEMS_CLASS_NAME),
    "LEGEND_LABEL_CLASS_NAME": (()=>LEGEND_LABEL_CLASS_NAME),
    "LEGEND_MAKER_CLASS_NAME": (()=>LEGEND_MAKER_CLASS_NAME),
    "LegendFilter": (()=>LegendFilter),
    "attributesOf": (()=>attributesOf),
    "dataOf": (()=>dataOf),
    "itemsOf": (()=>itemsOf),
    "labelOf": (()=>labelOf),
    "legendClearSetState": (()=>legendClearSetState),
    "legendsContinuousOf": (()=>legendsContinuousOf),
    "legendsOf": (()=>legendsOf),
    "markerOf": (()=>markerOf)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/deep-mix.js [app-client] (ecmascript) <export default as deepMix>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/throttle.js [app-client] (ecmascript) <export default as throttle>");
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
;
;
;
const CATEGORY_LEGEND_CLASS_NAME = 'legend-category';
const CONTINUOUS_LEGEND_CLASS_NAME = 'legend-continuous';
const LEGEND_ITEMS_CLASS_NAME = 'items-item';
const LEGEND_MAKER_CLASS_NAME = 'legend-category-item-marker';
const LEGEND_LABEL_CLASS_NAME = 'legend-category-item-label';
function markerOf(item) {
    return item.getElementsByClassName(LEGEND_MAKER_CLASS_NAME)[0];
}
function labelOf(item) {
    return item.getElementsByClassName(LEGEND_LABEL_CLASS_NAME)[0];
}
function itemsOf(root) {
    return root.getElementsByClassName(LEGEND_ITEMS_CLASS_NAME);
}
function legendsOf(root) {
    return root.getElementsByClassName(CATEGORY_LEGEND_CLASS_NAME);
}
function legendsContinuousOf(root) {
    return root.getElementsByClassName(CONTINUOUS_LEGEND_CLASS_NAME);
}
function legendClearSetState(root, setState) {
    const legends = [
        ...legendsOf(root),
        ...legendsContinuousOf(root)
    ];
    legends.forEach((legend)=>{
        setState(legend, (v)=>v);
    });
}
function dataOf(root) {
    // legend -> layout -> container
    let parent = root.parentNode;
    while(parent && !parent.__data__){
        parent = parent.parentNode;
    }
    return parent.__data__;
}
function attributesOf(root) {
    let child = root;
    while(child && !child.attr('class').startsWith('legend')){
        child = child.children[0];
    }
    return child.attributes;
}
function legendFilterOrdinal(root, { legends, marker: markerOf, label: labelOf, datum, filter, emitter, channel, state = {} }) {
    // Index handler by item.
    const itemClick = new Map();
    const itemPointerenter = new Map();
    const itemPointerout = new Map();
    const { unselected = {
        markerStroke: '#aaa',
        markerFill: '#aaa',
        labelFill: '#aaa'
    } } = state;
    const markerStyle = {
        unselected: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(unselected, 'marker')
    };
    const labelStyle = {
        unselected: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(unselected, 'label')
    };
    const { setState: setM, removeState: removeM } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(markerStyle, undefined);
    const { setState: setL, removeState: removeL } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(labelStyle, undefined);
    const items = Array.from(legends(root));
    let selectedValues = items.map(datum);
    const updateLegendState = ()=>{
        for (const item of items){
            const value = datum(item);
            const marker = markerOf(item);
            const label = labelOf(item);
            if (!selectedValues.includes(value)) {
                setM(marker, 'unselected');
                setL(label, 'unselected');
            } else {
                removeM(marker, 'unselected');
                removeL(label, 'unselected');
            }
        }
    };
    for (const item of items){
        // Defined handlers.
        const pointerenter = ()=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setCursor"])(root, 'pointer');
        };
        const pointerout = ()=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["restoreCursor"])(root);
        };
        const click = (event)=>__awaiter(this, void 0, void 0, function*() {
                const value = datum(item);
                const index = selectedValues.indexOf(value);
                if (index === -1) selectedValues.push(value);
                else selectedValues.splice(index, 1);
                yield filter(selectedValues);
                updateLegendState();
                const { nativeEvent = true } = event;
                if (!nativeEvent) return;
                if (selectedValues.length === items.length) {
                    emitter.emit('legend:reset', {
                        nativeEvent
                    });
                } else {
                    // Emit events.
                    emitter.emit('legend:filter', Object.assign(Object.assign({}, event), {
                        nativeEvent,
                        data: {
                            channel,
                            values: selectedValues
                        }
                    }));
                }
            });
        // Bind and store handlers.
        item.addEventListener('click', click);
        item.addEventListener('pointerenter', pointerenter);
        item.addEventListener('pointerout', pointerout);
        itemClick.set(item, click);
        itemPointerenter.set(item, pointerenter);
        itemPointerout.set(item, pointerout);
    }
    const onFilter = (event)=>__awaiter(this, void 0, void 0, function*() {
            const { nativeEvent } = event;
            if (nativeEvent) return;
            const { data } = event;
            const { channel: specifiedChannel, values } = data;
            if (specifiedChannel !== channel) return;
            selectedValues = values;
            yield filter(selectedValues);
            updateLegendState();
        });
    const onEnd = (event)=>__awaiter(this, void 0, void 0, function*() {
            const { nativeEvent } = event;
            if (nativeEvent) return;
            selectedValues = items.map(datum);
            yield filter(selectedValues);
            updateLegendState();
        });
    emitter.on('legend:filter', onFilter);
    emitter.on('legend:reset', onEnd);
    return ()=>{
        for (const item of items){
            item.removeEventListener('click', itemClick.get(item));
            item.removeEventListener('pointerenter', itemPointerenter.get(item));
            item.removeEventListener('pointerout', itemPointerout.get(item));
            emitter.off('legend:filter', onFilter);
            emitter.off('legend:reset', onEnd);
        }
    };
}
function legendFilterContinuous(_, { legend, filter, emitter, channel }) {
    const onValueChange = ({ detail: { value } })=>{
        filter(value);
        emitter.emit({
            nativeEvent: true,
            data: {
                channel,
                values: value
            }
        });
    };
    legend.addEventListener('valuechange', onValueChange);
    return ()=>{
        legend.removeEventListener('valuechange', onValueChange);
    };
}
function filterView(context, { legend, channel, value, ordinal, channels, allChannels, facet = false }) {
    return __awaiter(this, void 0, void 0, function*() {
        const { view, update, setState } = context;
        setState(legend, (viewOptions)=>{
            const { marks } = viewOptions;
            // Add filter transform for every marks,
            // which will skip for mark without color channel.
            const newMarks = marks.map((mark)=>{
                if (mark.type === 'legends') return mark;
                // Inset after aggregate transform, such as group, and bin.
                const { transform = [], data = [] } = mark;
                const index = transform.findIndex(({ type })=>type.startsWith('group') || type.startsWith('bin'));
                const newTransform = [
                    ...transform
                ];
                if (data.length) {
                    newTransform.splice(index + 1, 0, {
                        type: 'filter',
                        [channel]: {
                            value,
                            ordinal
                        }
                    });
                }
                // Set domain of scale to preserve encoding.
                const newScale = Object.fromEntries(channels.map((channel)=>[
                        channel,
                        {
                            domain: view.scale[channel].getOptions().domain
                        }
                    ]));
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({}, mark, Object.assign(Object.assign({
                    transform: newTransform,
                    scale: newScale
                }, !ordinal && {
                    animate: false
                }), {
                    legend: facet ? false : Object.fromEntries(allChannels.map((d)=>[
                            d,
                            {
                                preserve: true
                            }
                        ]))
                }));
            });
            return Object.assign(Object.assign({}, viewOptions), {
                marks: newMarks
            });
        });
        yield update();
    });
}
function filterFacets(facets, options) {
    for (const facet of facets){
        filterView(facet, Object.assign(Object.assign({}, options), {
            facet: true
        }));
    }
}
function LegendFilter() {
    return (context, contexts, emitter)=>{
        const { container } = context;
        const facets = contexts.filter((d)=>d !== context);
        const isFacet = facets.length > 0;
        const channelsOf = (legend)=>{
            return dataOf(legend).scales.map((d)=>d.name);
        };
        const legends = [
            ...legendsOf(container),
            ...legendsContinuousOf(container)
        ];
        const allChannels = legends.flatMap(channelsOf);
        const filter = isFacet ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__["throttle"])(filterFacets, 50, {
            trailing: true
        }) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__["throttle"])(filterView, 50, {
            trailing: true
        });
        const removes = legends.map((legend)=>{
            const { name: channel, domain } = dataOf(legend).scales[0];
            const channels = channelsOf(legend);
            const common = {
                legend,
                channel,
                channels,
                allChannels
            };
            if (legend.className === CATEGORY_LEGEND_CLASS_NAME) {
                return legendFilterOrdinal(container, {
                    legends: itemsOf,
                    marker: markerOf,
                    label: labelOf,
                    datum: (d)=>{
                        const { __data__: datum } = d;
                        const { index } = datum;
                        return domain[index];
                    },
                    filter: (value)=>{
                        const options = Object.assign(Object.assign({}, common), {
                            value,
                            ordinal: true
                        });
                        if (isFacet) filter(facets, options);
                        else filter(context, options);
                    },
                    state: legend.attributes.state,
                    channel,
                    emitter
                });
            } else {
                return legendFilterContinuous(container, {
                    legend,
                    filter: (value)=>{
                        const options = Object.assign(Object.assign({}, common), {
                            value,
                            ordinal: false
                        });
                        if (isFacet) filter(facets, options);
                        else filter(context, options);
                    },
                    emitter,
                    channel
                });
            }
        });
        return ()=>{
            removes.forEach((remove)=>remove());
        };
    };
} //# sourceMappingURL=legendFilter.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/legendHighlight.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "LegendHighlight": (()=>LegendHighlight)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$legendFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/legendFilter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/group.js [app-client] (ecmascript) <export default as group>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
;
;
;
;
function LegendHighlight() {
    return (context, _, emitter)=>{
        const { container, view, options } = context;
        const legends = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$legendFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["legendsOf"])(container);
        const elements = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectG2Elements"])(container);
        const channelOf = (legend)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$legendFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dataOf"])(legend).scales[0].name;
        };
        const scaleOf = (channel)=>{
            const { scale: { [channel]: scale } } = view;
            return scale;
        };
        const markState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeState"])(options, [
            'active',
            'inactive'
        ]);
        const valueof = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createValueof"])(elements, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDatumof"])(view));
        const destroys = [];
        // Bind events for each legend.
        for (const legend of legends){
            const datumOf = (item)=>{
                const { data } = legend.attributes;
                const { __data__: datum } = item;
                const { index } = datum;
                return data[index].label;
            };
            const channel = channelOf(legend);
            const items = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$legendFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["itemsOf"])(legend);
            const scale = scaleOf(channel);
            const elementGroup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$group$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__group$3e$__["group"])(elements, (d)=>scale.invert(d.__data__[channel]));
            const { state: legendState = {} } = legend.attributes;
            const { inactive = {} } = legendState;
            const { setState, removeState } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(markState, valueof);
            // Handle styles of inner item.
            const markerStyle = {
                inactive: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(inactive, 'marker')
            };
            const labelStyle = {
                inactive: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(inactive, 'label')
            };
            const { setState: setM, removeState: removeM } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(markerStyle);
            const { setState: setL, removeState: removeL } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(labelStyle);
            const updateLegendState = (highlight)=>{
                for (const item of items){
                    const marker = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$legendFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markerOf"])(item);
                    const label = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$legendFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["labelOf"])(item);
                    if (item === highlight || highlight === null) {
                        removeM(marker, 'inactive');
                        removeL(label, 'inactive');
                    } else {
                        setM(marker, 'inactive');
                        setL(label, 'inactive');
                    }
                }
            };
            const highlightItem = (event, item)=>{
                // Update UI.
                const value = datumOf(item);
                const elementSet = new Set(elementGroup.get(value));
                for (const e of elements){
                    if (elementSet.has(e)) setState(e, 'active');
                    else setState(e, 'inactive');
                }
                updateLegendState(item);
                // Emit events.
                const { nativeEvent = true } = event;
                if (!nativeEvent) return;
                emitter.emit('legend:highlight', Object.assign(Object.assign({}, event), {
                    nativeEvent,
                    data: {
                        channel,
                        value
                    }
                }));
            };
            const itemPointerover = new Map();
            // Add listener for the legend items.
            for (const item of items){
                const pointerover = (event)=>{
                    highlightItem(event, item);
                };
                item.addEventListener('pointerover', pointerover);
                itemPointerover.set(item, pointerover);
            }
            // Add listener for the legend group.
            const pointerleave = (event)=>{
                for (const e of elements)removeState(e, 'inactive', 'active');
                updateLegendState(null);
                // Emit events.
                const { nativeEvent = true } = event;
                if (!nativeEvent) return;
                emitter.emit('legend:unhighlight', {
                    nativeEvent
                });
            };
            const onHighlight = (event)=>{
                const { nativeEvent, data } = event;
                if (nativeEvent) return;
                const { channel: specifiedChannel, value } = data;
                if (specifiedChannel !== channel) return;
                const item = items.find((d)=>datumOf(d) === value);
                if (!item) return;
                highlightItem({
                    nativeEvent: false
                }, item);
            };
            const onUnHighlight = (event)=>{
                const { nativeEvent } = event;
                if (nativeEvent) return;
                pointerleave({
                    nativeEvent: false
                });
            };
            legend.addEventListener('pointerleave', pointerleave);
            emitter.on('legend:highlight', onHighlight);
            emitter.on('legend:unhighlight', onUnHighlight);
            const destroy = ()=>{
                legend.removeEventListener(pointerleave);
                emitter.off('legend:highlight', onHighlight);
                emitter.off('legend:unhighlight', onUnHighlight);
                for (const [item, pointerover] of itemPointerover){
                    item.removeEventListener(pointerover);
                }
            };
            destroys.push(destroy);
        }
        return ()=>destroys.forEach((d)=>d());
    };
} //# sourceMappingURL=legendHighlight.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/brushHighlight.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "BrushHighlight": (()=>BrushHighlight),
    "brush": (()=>brush),
    "brushHighlight": (()=>brushHighlight)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/g/dist/index.esm.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$createElement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/createElement.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$selection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/selection.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g-lite/dist/index.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/scale.js [app-client] (ecmascript)");
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
;
;
;
;
function intersect(bbox1, bbox2) {
    const [minX1, minY1, maxX1, maxY1] = bbox1;
    const [minX2, minY2, maxX2, maxY2] = bbox2;
    return !(minX2 > maxX1 || maxX2 < minX1 || minY2 > maxY1 || maxY2 < minY1);
}
function normalizeBounds(x, y, x1, y1, extent) {
    const [minX, minY, maxX, maxY] = extent;
    return [
        Math.max(minX, Math.min(x, x1)),
        Math.max(minY, Math.min(y, y1)),
        Math.min(maxX, Math.max(x, x1)),
        Math.min(maxY, Math.max(y, y1))
    ];
}
function bboxOf(root) {
    const { width, height } = root.getBBox();
    return [
        0,
        0,
        width,
        height
    ];
}
function applyStyle(selection, style) {
    for (const [key, value] of Object.entries(style)){
        selection.style(key, value);
    }
}
const ResizableMask = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$createElement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])((g)=>{
    const _a = g.attributes, { x, y, width, height, class: className, renders = {}, handleSize: size = 10, document } = _a, style = __rest(_a, [
        "x",
        "y",
        "width",
        "height",
        "class",
        "renders",
        "handleSize",
        "document"
    ]);
    if (!document || width === undefined || height === undefined || x === undefined || y === undefined) return;
    const half = size / 2;
    const renderRect = (g, options, document)=>{
        if (!g.handle) {
            g.handle = document.createElement('rect');
            g.append(g.handle);
        }
        const { handle } = g;
        handle.attr(options);
        return handle;
    };
    const _b = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["omitPrefixObject"])(style, 'handleNW', 'handleNE'), 'handleN'), { render: handleNRender = renderRect } = _b, handleNStyle = __rest(_b, [
        "render"
    ]);
    const _c = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'handleE'), { render: handleERender = renderRect } = _c, handleEStyle = __rest(_c, [
        "render"
    ]);
    const _d = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["omitPrefixObject"])(style, 'handleSE', 'handleSW'), 'handleS'), { render: handleSRender = renderRect } = _d, handleSStyle = __rest(_d, [
        "render"
    ]);
    const _e = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'handleW'), { render: handleWRender = renderRect } = _e, handleWStyle = __rest(_e, [
        "render"
    ]);
    const _f = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'handleNW'), { render: handleNWRender = renderRect } = _f, handleNWStyle = __rest(_f, [
        "render"
    ]);
    const _g = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'handleNE'), { render: handleNERender = renderRect } = _g, handleNEStyle = __rest(_g, [
        "render"
    ]);
    const _h = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'handleSE'), { render: handleSERender = renderRect } = _h, handleSEStyle = __rest(_h, [
        "render"
    ]);
    const _j = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'handleSW'), { render: handleSWRender = renderRect } = _j, handleSWStyle = __rest(_j, [
        "render"
    ]);
    const renderHandle = (g, renderNode)=>{
        const { id } = g;
        const handle = renderNode(g, g.attributes, document);
        handle.id = id;
        handle.style.draggable = true;
    };
    const appendHandle = (handleRender)=>{
        return ()=>{
            const Node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$createElement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])((g)=>renderHandle(g, handleRender));
            return new Node({});
        };
    };
    const container = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$selection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["select"])(g).attr('className', className).style('transform', `translate(${x}, ${y})`).style('draggable', true);
    container.maybeAppend('selection', 'rect').style('draggable', true).style('fill', 'transparent').call(applyStyle, Object.assign(Object.assign({
        width,
        height
    }, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["omitPrefixObject"])(style, 'handle')), {
        transform: undefined
    }));
    container.maybeAppend('handle-n', appendHandle(handleNRender)).style('x', half).style('y', -half).style('width', width - size).style('height', size).style('fill', 'transparent').call(applyStyle, handleNStyle);
    container.maybeAppend('handle-e', appendHandle(handleERender)).style('x', width - half).style('y', half).style('width', size).style('height', height - size).style('fill', 'transparent').call(applyStyle, handleEStyle);
    container.maybeAppend('handle-s', appendHandle(handleSRender)).style('x', half).style('y', height - half).style('width', width - size).style('height', size).style('fill', 'transparent').call(applyStyle, handleSStyle);
    container.maybeAppend('handle-w', appendHandle(handleWRender)).style('x', -half).style('y', half).style('width', size).style('height', height - size).style('fill', 'transparent').call(applyStyle, handleWStyle);
    container.maybeAppend('handle-nw', appendHandle(handleNWRender)).style('x', -half).style('y', -half).style('width', size).style('height', size).style('fill', 'transparent').call(applyStyle, handleNWStyle);
    container.maybeAppend('handle-ne', appendHandle(handleNERender)).style('x', width - half).style('y', -half).style('width', size).style('height', size).style('fill', 'transparent').call(applyStyle, handleNEStyle);
    container.maybeAppend('handle-se', appendHandle(handleSERender)).style('x', width - half).style('y', height - half).style('width', size).style('height', size).style('fill', 'transparent').call(applyStyle, handleSEStyle);
    container.maybeAppend('handle-sw', appendHandle(handleSWRender)).style('x', -half).style('y', height - half).style('width', size).style('height', size).style('fill', 'transparent').call(applyStyle, handleSWStyle);
});
function brush(root, _a) {
    var { brushed = ()=>{}, brushended = ()=>{}, brushcreated = ()=>{}, brushstarted = ()=>{}, brushupdated = ()=>{}, extent = bboxOf(root), brushRegion = (x, y, x1, y1, extent)=>[
            x,
            y,
            x1,
            y1
        ], reverse = false, fill = '#777', fillOpacity = '0.3', stroke = '#fff', selectedHandles = [
        'handle-n',
        'handle-e',
        'handle-s',
        'handle-w',
        'handle-nw',
        'handle-ne',
        'handle-se',
        'handle-sw'
    ] } = _a, style = __rest(_a, [
        "brushed",
        "brushended",
        "brushcreated",
        "brushstarted",
        "brushupdated",
        "extent",
        "brushRegion",
        "reverse",
        "fill",
        "fillOpacity",
        "stroke",
        "selectedHandles"
    ]);
    let start = null; // Start point of mask.
    let end = null; // End point of mask.
    let moveStart = null; // Start point of moving mask.
    let mask = null; // Mask instance.
    let background = null;
    let creating = false;
    const [originX, originY, width, height] = extent;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setCursor"])(root, 'crosshair');
    root.style.draggable = true; // Make it response to drag event.
    // Remove old mask and init new mask.
    const initMask = (x, y, event)=>{
        brushstarted(event);
        if (mask) mask.remove();
        if (background) background.remove();
        start = [
            x,
            y
        ];
        if (reverse) return initReverseMask();
        initNormalMask();
    };
    const initReverseMask = ()=>{
        background = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"]({
            style: Object.assign(Object.assign({}, style), {
                fill,
                fillOpacity,
                stroke,
                pointerEvents: 'none'
            })
        });
        mask = new ResizableMask({
            // @ts-ignore
            style: {
                x: 0,
                y: 0,
                width: 0,
                height: 0,
                draggable: true,
                document: root.ownerDocument
            },
            className: 'mask'
        });
        root.appendChild(background);
        root.appendChild(mask);
    };
    const initNormalMask = ()=>{
        mask = new ResizableMask({
            // @ts-ignore
            style: Object.assign(Object.assign({
                document: root.ownerDocument,
                x: 0,
                y: 0
            }, style), {
                fill,
                fillOpacity,
                stroke,
                draggable: true
            }),
            className: 'mask'
        });
        root.appendChild(mask);
    };
    // Remove mask and reset states.
    const removeMask = (emit = true)=>{
        if (mask) mask.remove();
        if (background) background.remove();
        start = null;
        end = null;
        moveStart = null;
        creating = false;
        mask = null;
        background = null;
        brushended(emit);
    };
    // Update mask and invoke brushended callback.
    const updateMask = (start, end, emit = true)=>{
        const [x, y, x1, y1] = normalizeBounds(start[0], start[1], end[0], end[1], extent);
        const [fx, fy, fx1, fy1] = brushRegion(x, y, x1, y1, extent);
        if (reverse) updateReverseMask(fx, fy, fx1, fy1);
        else updateNormalMask(fx, fy, fx1, fy1);
        brushed(fx, fy, fx1, fy1, emit);
        return [
            fx,
            fy,
            fx1,
            fy1
        ];
    };
    const updateNormalMask = (x, y, x1, y1)=>{
        mask.style.x = x;
        mask.style.y = y;
        mask.style.width = x1 - x;
        mask.style.height = y1 - y;
    };
    const updateReverseMask = (x, y, x1, y1)=>{
        background.style.d = `
      M${originX},${originY}L${width},${originY}L${width},${height}L${originX},${height}Z
      M${x},${y}L${x},${y1}L${x1},${y1}L${x1},${y}Z
    `;
        mask.style.x = x;
        mask.style.y = y;
        mask.style.width = x1 - x;
        mask.style.height = y1 - y;
    };
    // Move and update mask.
    const moveMask = (current)=>{
        const clip = (dt, start, end, min, max)=>{
            if (dt + start < min) return min - start;
            if (dt + end > max) return max - end;
            return dt;
        };
        const dx = current[0] - moveStart[0];
        const dy = current[1] - moveStart[1];
        const dx1 = clip(dx, start[0], end[0], originX, width);
        const dy1 = clip(dy, start[1], end[1], originY, height);
        const currentStart = [
            start[0] + dx1,
            start[1] + dy1
        ];
        const currentEnd = [
            end[0] + dx1,
            end[1] + dy1
        ];
        updateMask(currentStart, currentEnd);
    };
    const handles = {
        'handle-n': {
            vector: [
                0,
                1,
                0,
                0
            ],
            cursor: 'ns-resize'
        },
        'handle-e': {
            vector: [
                0,
                0,
                1,
                0
            ],
            cursor: 'ew-resize'
        },
        'handle-s': {
            vector: [
                0,
                0,
                0,
                1
            ],
            cursor: 'ns-resize'
        },
        'handle-w': {
            vector: [
                1,
                0,
                0,
                0
            ],
            cursor: 'ew-resize'
        },
        'handle-nw': {
            vector: [
                1,
                1,
                0,
                0
            ],
            cursor: 'nwse-resize'
        },
        'handle-ne': {
            vector: [
                0,
                1,
                1,
                0
            ],
            cursor: 'nesw-resize'
        },
        'handle-se': {
            vector: [
                0,
                0,
                1,
                1
            ],
            cursor: 'nwse-resize'
        },
        'handle-sw': {
            vector: [
                1,
                0,
                0,
                1
            ],
            cursor: 'nesw-resize'
        }
    };
    const isMask = (target)=>{
        return isSelection(target) || isHandle(target);
    };
    const isHandle = (target)=>{
        const { id } = target;
        if (selectedHandles.indexOf(id) === -1) return false;
        return new Set(Object.keys(handles)).has(id);
    };
    const isSelection = (target)=>{
        return target === mask.getElementById('selection');
    };
    // If target is plot area, create mask.
    // If target is mask, about to update position.
    const dragstart = (event)=>{
        const { target } = event;
        const [offsetX, offsetY] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["brushMousePosition"])(root, event);
        if (!mask || !isMask(target)) {
            initMask(offsetX, offsetY, event);
            creating = true;
            return;
        }
        if (isMask(target)) {
            moveStart = [
                offsetX,
                offsetY
            ];
        }
    };
    const drag = (event)=>{
        const { target } = event;
        const mouse = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["brushMousePosition"])(root, event);
        if (!start) return;
        // If target is plot area, resize mask.
        if (!moveStart) return updateMask(start, mouse);
        // If target is selection area, move mask.
        if (isSelection(target)) return moveMask(mouse);
        // If target is handle area, resize mask.
        const [dx, dy] = [
            mouse[0] - moveStart[0],
            mouse[1] - moveStart[1]
        ];
        const { id } = target;
        if (handles[id]) {
            const [sx, sy, ex, ey] = handles[id].vector;
            return updateMask([
                start[0] + dx * sx,
                start[1] + dy * sy
            ], [
                end[0] + dx * ex,
                end[1] + dy * ey
            ]);
        }
    };
    // If target is plot area, finish creating.
    // If target is mask, finish moving mask.
    const dragend = (event)=>{
        if (moveStart) {
            moveStart = null;
            // Update start and end;
            const { x, y, width, height } = mask.style;
            start = [
                x,
                y
            ];
            end = [
                x + width,
                y + height
            ];
            brushupdated(x, y, x + width, y + height, event);
            return;
        }
        end = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["brushMousePosition"])(root, event);
        const [fx, fy, fx1, fy1] = updateMask(start, end);
        creating = false;
        brushcreated(fx, fy, fx1, fy1, event);
    };
    // Hide mask.
    const click = (event)=>{
        const { target } = event;
        if (mask && !isMask(target)) removeMask();
    };
    // Update cursor depends on hovered element.
    const pointermove = (event)=>{
        const { target } = event;
        if (!mask || !isMask(target) || creating) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setCursor"])(root, 'crosshair');
        else if (isSelection(target)) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setCursor"])(root, 'move');
        else if (isHandle(target)) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setCursor"])(root, handles[target.id].cursor);
    };
    const pointerleave = ()=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setCursor"])(root, 'default');
    };
    root.addEventListener('dragstart', dragstart);
    root.addEventListener('drag', drag);
    root.addEventListener('dragend', dragend);
    root.addEventListener('click', click);
    root.addEventListener('pointermove', pointermove);
    root.addEventListener('pointerleave', pointerleave);
    return {
        mask,
        move (x, y, x1, y1, emit = true) {
            if (!mask) initMask(x, y, {});
            start = [
                x,
                y
            ];
            end = [
                x1,
                y1
            ];
            updateMask([
                x,
                y
            ], [
                x1,
                y1
            ], emit);
        },
        remove (emit = true) {
            if (mask) removeMask(emit);
        },
        destroy () {
            // Do not emit brush:end event.
            if (mask) removeMask(false);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setCursor"])(root, 'default');
            root.removeEventListener('dragstart', dragstart);
            root.removeEventListener('drag', drag);
            root.removeEventListener('dragend', dragend);
            root.removeEventListener('click', click);
            root.removeEventListener('pointermove', pointermove);
            root.removeEventListener('pointerleave', pointerleave);
        }
    };
}
function selectSiblingViews(target, viewInstances, brushKey) {
    return viewInstances.filter((d)=>{
        if (d === target) return false;
        const { interaction = {} } = d.options;
        return Object.values(interaction).find((d)=>d.brushKey === brushKey);
    });
}
function selectSiblingContainers(target, viewInstances, brushKey) {
    return selectSiblingViews(target, viewInstances, brushKey).map((d)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectPlotArea"])(d.container));
}
function selectSiblingOptions(target, viewInstances, brushKey) {
    return selectSiblingViews(target, viewInstances, brushKey).map((d)=>d.options);
}
function brushHighlight(root, _a) {
    var { elements: elementof, selectedHandles, siblings: siblingsof = (root)=>[], datum, brushRegion, extent: optionalExtent, reverse, scale, coordinate, series = false, key = (d)=>d, bboxOf = (root)=>{
        const { x, y, width, height } = root.style;
        return {
            x,
            y,
            width,
            height
        };
    }, state = {}, emitter } = _a, rest = __rest(_a, [
        "elements",
        "selectedHandles",
        "siblings",
        "datum",
        "brushRegion",
        "extent",
        "reverse",
        "scale",
        "coordinate",
        "series",
        "key",
        "bboxOf",
        "state",
        "emitter"
    ]);
    const elements = elementof(root);
    const siblings = siblingsof(root);
    const siblingElements = siblings.flatMap(elementof);
    const valueof = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createValueof"])(elements, datum);
    const brushStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(rest, 'mask');
    const { setState, removeState } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(state, valueof);
    const clonedElement = new Map();
    const { width: rootWidth, height: rootHeight, x: ordinalX = 0, y: ordinalY = 0 } = bboxOf(root);
    const extent = optionalExtent ? optionalExtent : [
        0,
        0,
        rootWidth,
        rootHeight
    ];
    const brushended = ()=>{
        for (const element of [
            ...elements,
            ...siblingElements
        ]){
            removeState(element, 'active', 'inactive');
        }
    };
    const brushed = (x, y, x1, y1)=>{
        var _a;
        // Hide brush for the sibling view.
        for (const sibling of siblings)(_a = sibling.brush) === null || _a === void 0 ? void 0 : _a.remove();
        // Store the key of the active element.
        const keys = new Set();
        // Highlight and store selected elements.
        for (const element of elements){
            const { min, max } = element.getLocalBounds();
            const [ex, ey] = min;
            const [ex1, ey1] = max;
            if (!intersect([
                ex,
                ey,
                ex1,
                ey1
            ], [
                x,
                y,
                x1,
                y1
            ])) {
                setState(element, 'inactive');
            } else {
                setState(element, 'active');
                keys.add(key(element));
            }
        }
        // Highlight elements with same key in sibling view.
        for (const element of siblingElements){
            if (keys.has(key(element))) setState(element, 'active');
            else setState(element, 'inactive');
        }
    };
    const seriesBrushend = ()=>{
        for (const element of elements)removeState(element, 'inactive');
        for (const cloned of clonedElement.values())cloned.remove();
        clonedElement.clear();
    };
    const seriesBrushed = (x, y, x1, y1)=>{
        const clone = (element)=>{
            const cloned = element.cloneNode();
            cloned.__data__ = element.__data__;
            element.parentNode.appendChild(cloned);
            clonedElement.set(element, cloned);
            return cloned;
        };
        // Create a clipPath shared between all children.
        const clipPath = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"]({
            style: {
                x: x + ordinalX,
                y: y + ordinalY,
                width: x1 - x,
                height: y1 - y
            }
        });
        root.appendChild(clipPath);
        for (const element of elements){
            const cloned = clonedElement.get(element) || clone(element);
            cloned.style.clipPath = clipPath;
            setState(element, 'inactive');
            setState(cloned, 'active');
        }
    };
    const brushHandler = brush(root, Object.assign(Object.assign({}, brushStyle), {
        extent,
        brushRegion,
        reverse,
        selectedHandles,
        brushended: (emit)=>{
            const handler = series ? seriesBrushend : brushended;
            if (emit) {
                emitter.emit('brush:remove', {
                    nativeEvent: true
                });
            }
            handler();
        },
        brushed: (x, y, x1, y1, emit)=>{
            const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectionOf"])(x, y, x1, y1, scale, coordinate);
            if (emit) {
                emitter.emit('brush:highlight', {
                    nativeEvent: true,
                    data: {
                        selection
                    }
                });
            }
            const handler = series ? seriesBrushed : brushed;
            handler(x, y, x1, y1);
        },
        brushcreated: (x, y, x1, y1, event)=>{
            const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectionOf"])(x, y, x1, y1, scale, coordinate);
            emitter.emit('brush:end', Object.assign(Object.assign({}, event), {
                nativeEvent: true,
                data: {
                    selection
                }
            }));
        },
        brushupdated: (x, y, x1, y1, event)=>{
            const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectionOf"])(x, y, x1, y1, scale, coordinate);
            emitter.emit('brush:end', Object.assign(Object.assign({}, event), {
                nativeEvent: true,
                data: {
                    selection
                }
            }));
        },
        brushstarted: (e)=>{
            emitter.emit('brush:start', e);
        }
    }));
    // Move brush and highlight data.
    const onHighlight = ({ nativeEvent, data })=>{
        if (nativeEvent) return;
        const { selection } = data;
        const [x, y, x1, y1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pixelsOf"])(selection, scale, coordinate);
        brushHandler.move(x, y, x1, y1, false);
    };
    emitter.on('brush:highlight', onHighlight);
    // Remove brush and reset data.
    const onRemove = ({ nativeEvent } = {})=>{
        if (nativeEvent) return;
        brushHandler.remove(false);
    };
    emitter.on('brush:remove', onRemove);
    // Remove event handlers.
    const preBrushDestroy = brushHandler.destroy.bind(brushHandler);
    brushHandler.destroy = ()=>{
        emitter.off('brush:highlight', onHighlight);
        emitter.off('brush:remove', onRemove);
        preBrushDestroy();
    };
    return brushHandler;
}
function BrushHighlight(_a) {
    var { facet, brushKey } = _a, rest = __rest(_a, [
        "facet",
        "brushKey"
    ]);
    return (target, viewInstances, emitter)=>{
        const { container, view, options } = target;
        const plotArea = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectPlotArea"])(container);
        const defaultOptions = {
            maskFill: '#777',
            maskFillOpacity: '0.3',
            maskStroke: '#fff',
            reverse: false
        };
        const defaultStates = [
            'active',
            [
                'inactive',
                {
                    opacity: 0.5
                }
            ]
        ];
        const { scale, coordinate } = view;
        if (facet) {
            const bbox = plotArea.getBounds();
            const x = bbox.min[0];
            const y = bbox.min[1];
            const x1 = bbox.max[0];
            const y1 = bbox.max[1];
            return brushHighlight(plotArea.parentNode.parentNode, Object.assign(Object.assign({
                elements: ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectFacetG2Elements"])(target, viewInstances),
                datum: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDatumof"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectFacetViews"])(target, viewInstances).map((d)=>d.view)),
                brushRegion: (x, y, x1, y1)=>[
                        x,
                        y,
                        x1,
                        y1
                    ],
                extent: [
                    x,
                    y,
                    x1,
                    y1
                ],
                state: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeState"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectFacetViews"])(target, viewInstances).map((d)=>d.options), defaultStates),
                emitter,
                scale,
                coordinate,
                selectedHandles: undefined
            }, defaultOptions), rest));
        }
        const brush = brushHighlight(plotArea, Object.assign(Object.assign({
            elements: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectG2Elements"],
            key: (element)=>element.__data__.key,
            siblings: ()=>selectSiblingContainers(target, viewInstances, brushKey),
            datum: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDatumof"])([
                view,
                ...selectSiblingViews(target, viewInstances, brushKey).map((d)=>d.view)
            ]),
            brushRegion: (x, y, x1, y1)=>[
                    x,
                    y,
                    x1,
                    y1
                ],
            extent: undefined,
            state: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeState"])([
                options,
                ...selectSiblingOptions(target, viewInstances, brushKey)
            ], defaultStates),
            emitter,
            scale,
            coordinate,
            selectedHandles: undefined
        }, defaultOptions), rest));
        // Bind brush to the view it belongs to.
        //@ts-ignore
        plotArea.brush = brush;
        return ()=>brush.destroy();
    };
} //# sourceMappingURL=brushHighlight.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/brushXHighlight.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "BrushXHighlight": (()=>BrushXHighlight),
    "brushXRegion": (()=>brushXRegion)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/brushHighlight.js [app-client] (ecmascript)");
;
function brushXRegion(x, y, x1, y1, extent) {
    const [, minY, , maxY] = extent;
    return [
        x,
        minY,
        x1,
        maxY
    ];
}
function BrushXHighlight(options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BrushHighlight"])(Object.assign(Object.assign({}, options), {
        brushRegion: brushXRegion,
        selectedHandles: [
            'handle-e',
            'handle-w'
        ]
    }));
} //# sourceMappingURL=brushXHighlight.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/brushYHighlight.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "BrushYHighlight": (()=>BrushYHighlight),
    "brushYRegion": (()=>brushYRegion)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/brushHighlight.js [app-client] (ecmascript)");
;
function brushYRegion(x, y, x1, y1, extent) {
    const [minX, , maxX] = extent;
    return [
        minX,
        y,
        maxX,
        y1
    ];
}
function BrushYHighlight(options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BrushHighlight"])(Object.assign(Object.assign({}, options), {
        brushRegion: brushYRegion,
        selectedHandles: [
            'handle-n',
            'handle-s'
        ]
    }));
} //# sourceMappingURL=brushYHighlight.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/brushAxisHighlight.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "AXIS_CLASS_NAME": (()=>AXIS_CLASS_NAME),
    "AXIS_HOT_AREA_CLASS_NAME": (()=>AXIS_HOT_AREA_CLASS_NAME),
    "AXIS_LINE_CLASS_NAME": (()=>AXIS_LINE_CLASS_NAME),
    "AXIS_MAIN_CLASS_NAME": (()=>AXIS_MAIN_CLASS_NAME),
    "BrushAxisHighlight": (()=>BrushAxisHighlight),
    "brushAxisHighlight": (()=>brushAxisHighlight)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/g/dist/index.esm.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushYHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/brushYHighlight.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g-lite/dist/index.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushXHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/brushXHighlight.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/scale.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/brushHighlight.js [app-client] (ecmascript)");
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
;
;
;
;
;
const AXIS_CLASS_NAME = 'axis';
const AXIS_LINE_CLASS_NAME = 'axis-line';
const AXIS_MAIN_CLASS_NAME = 'axis-main-group';
const AXIS_HOT_AREA_CLASS_NAME = 'axis-hot-area';
function axesOf(container) {
    return container.getElementsByClassName(AXIS_CLASS_NAME);
}
function lineOf(axis) {
    return axis.getElementsByClassName(AXIS_LINE_CLASS_NAME)[0];
}
function mainGroupOf(axis) {
    return axis.getElementsByClassName(AXIS_MAIN_CLASS_NAME)[0];
}
// Use the bounds of main group of axis as the bounds of axis,
// get rid of grid and title.
function boundsOfAxis(axis) {
    return mainGroupOf(axis).getLocalBounds();
}
// Brush for vertical axis.
function verticalBrush(axis, _a) {
    var { cross, offsetX, offsetY } = _a, style = __rest(_a, [
        "cross",
        "offsetX",
        "offsetY"
    ]);
    const bounds = boundsOfAxis(axis);
    const axisLine = lineOf(axis);
    const [lineX] = axisLine.getLocalBounds().min;
    const [minX, minY] = bounds.min;
    const [maxX, maxY] = bounds.max;
    const size = (maxX - minX) * 2;
    return {
        brushRegion: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushYHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["brushYRegion"],
        hotZone: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"]({
            className: AXIS_HOT_AREA_CLASS_NAME,
            style: Object.assign({
                // If it is not cross, draw brush in both side of axisLine,
                // otherwise the draw brush within bounds area.
                width: cross ? size / 2 : size,
                transform: `translate(${(cross ? minX : lineX - size / 2).toFixed(2)}, ${minY})`,
                height: maxY - minY
            }, style)
        }),
        extent: cross ? (x, y, x1, y1)=>[
                -Infinity,
                y,
                Infinity,
                y1
            ] : (x, y, x1, y1)=>[
                Math.floor(minX - offsetX),
                y,
                Math.ceil(maxX - offsetX),
                y1
            ]
    };
}
// Brush for horizontal axis.
function horizontalBrush(axis, _a) {
    var { offsetY, offsetX, cross = false } = _a, style = __rest(_a, [
        "offsetY",
        "offsetX",
        "cross"
    ]);
    const bounds = boundsOfAxis(axis);
    const axisLine = lineOf(axis);
    const [, lineY] = axisLine.getLocalBounds().min;
    const [minX, minY] = bounds.min;
    const [maxX, maxY] = bounds.max;
    const size = maxY - minY;
    return {
        brushRegion: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushXHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["brushXRegion"],
        hotZone: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"]({
            className: AXIS_HOT_AREA_CLASS_NAME,
            style: Object.assign({
                width: maxX - minX,
                // If it is not cross, draw brush in both side of axisLine,
                // otherwise the draw brush within bounds area.
                height: cross ? size : size * 2,
                transform: `translate(${minX}, ${cross ? minY : lineY - size})`
            }, style)
        }),
        extent: cross ? (x, y, x1, y1)=>[
                x,
                -Infinity,
                x1,
                Infinity
            ] : (x, y, x1, y1)=>[
                x,
                Math.floor(minY - offsetY),
                x1,
                Math.ceil(maxY - offsetY)
            ]
    };
}
function brushAxisHighlight(root, _a) {
    var { axes: axesOf, elements: elementsOf, points: pointsOf, horizontal: isHorizontal, datum, offsetY, offsetX, reverse = false, state = {}, emitter, coordinate } = _a, rest = __rest(_a, [
        "axes",
        "elements",
        "points",
        "horizontal",
        "datum",
        "offsetY",
        "offsetX",
        "reverse",
        "state",
        "emitter",
        "coordinate"
    ]) // style
    ;
    const elements = elementsOf(root);
    const axes = axesOf(root);
    const valueof = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createValueof"])(elements, datum);
    const { setState, removeState } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(state, valueof);
    const axisExtent = new Map();
    const brushStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(rest, 'mask');
    // Only some of shape's points in all mask, it is selected.
    const brushed = (points)=>Array.from(axisExtent.values()).every(([x, y, x1, y1])=>points.some(([x0, y0])=>{
                return x0 >= x && x0 <= x1 && y0 >= y && y0 <= y1;
            }));
    const scales = axes.map((d)=>d.attributes.scale);
    const extentOf = (D)=>D.length > 2 ? [
            D[0],
            D[D.length - 1]
        ] : D;
    const indexDomain = new Map();
    const initIndexDomain = ()=>{
        indexDomain.clear();
        for(let i = 0; i < axes.length; i++){
            const scale = scales[i];
            const { domain } = scale.getOptions();
            indexDomain.set(i, extentOf(domain));
        }
    };
    initIndexDomain();
    // Update element when brush changed.
    const updateElement = (i, emit)=>{
        const selectedElements = [];
        for (const element of elements){
            const points = pointsOf(element);
            if (brushed(points)) {
                setState(element, 'active');
                selectedElements.push(element);
            } else setState(element, 'inactive');
        }
        indexDomain.set(i, selectionOf(selectedElements, i));
        if (!emit) return;
        // Emit events.
        const selection = ()=>{
            if (!cross) return Array.from(indexDomain.values());
            const S = [];
            for (const [index, domain] of indexDomain){
                const scale = scales[index];
                const { name } = scale.getOptions();
                if (name === 'x') S[0] = domain;
                else S[1] = domain;
            }
            return S;
        };
        emitter.emit('brushAxis:highlight', {
            nativeEvent: true,
            data: {
                selection: selection()
            }
        });
    };
    const clearElement = (emit)=>{
        for (const element of elements)removeState(element, 'active', 'inactive');
        initIndexDomain();
        if (!emit) return;
        emitter.emit('brushAxis:remove', {
            nativeEvent: true
        });
    };
    const selectionOf = (selected, i)=>{
        const scale = scales[i];
        const { name } = scale.getOptions();
        const domain = selected.map((d)=>{
            const data = d.__data__;
            return scale.invert(data[name]);
        });
        return extentOf((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["domainOf"])(scale, domain));
    };
    // Distinguish between parallel coordinates and normal charts.
    const cross = axes.some(isHorizontal) && axes.some((d)=>!isHorizontal(d));
    const handlers = [];
    for(let i = 0; i < axes.length; i++){
        const axis = axes[i];
        const createBrush = isHorizontal(axis) ? horizontalBrush : verticalBrush;
        const { hotZone, brushRegion, extent } = createBrush(axis, {
            offsetY,
            offsetX,
            cross,
            zIndex: 999,
            fill: 'transparent'
        });
        axis.parentNode.appendChild(hotZone);
        const brushHandler = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["brush"])(hotZone, Object.assign(Object.assign({}, brushStyle), {
            reverse,
            brushRegion,
            brushended (emit) {
                axisExtent.delete(axis);
                if (Array.from(axisExtent.entries()).length === 0) clearElement(emit);
                else updateElement(i, emit);
            },
            brushed (x, y, x1, y1, emit) {
                axisExtent.set(axis, extent(x, y, x1, y1));
                updateElement(i, emit);
            }
        }));
        handlers.push(brushHandler);
    }
    const onRemove = (event = {})=>{
        const { nativeEvent } = event;
        if (nativeEvent) return;
        handlers.forEach((d)=>d.remove(false));
    };
    const rangeOf = (domain, scale, axis)=>{
        const [d0, d1] = domain;
        const maybeStep = (scale)=>scale.getStep ? scale.getStep() : 0;
        const x = abstractOf(d0, scale, axis);
        const x1 = abstractOf(d1, scale, axis) + maybeStep(scale);
        if (isHorizontal(axis)) return [
            x,
            -Infinity,
            x1,
            Infinity
        ];
        return [
            -Infinity,
            x,
            Infinity,
            x1
        ];
    };
    const abstractOf = (x, scale, axis)=>{
        const { height, width } = coordinate.getOptions();
        const scale1 = scale.clone();
        if (isHorizontal(axis)) scale1.update({
            range: [
                0,
                width
            ]
        });
        else scale1.update({
            range: [
                height,
                0
            ]
        });
        return scale1.map(x);
    };
    const onHighlight = (event)=>{
        const { nativeEvent } = event;
        if (nativeEvent) return;
        const { selection } = event.data;
        for(let i = 0; i < handlers.length; i++){
            const domain = selection[i];
            const handler = handlers[i];
            const axis = axes[i];
            if (domain) {
                const scale = scales[i];
                handler.move(...rangeOf(domain, scale, axis), false);
            } else {
                handler.remove(false);
            }
        }
    };
    emitter.on('brushAxis:remove', onRemove);
    emitter.on('brushAxis:highlight', onHighlight);
    return ()=>{
        handlers.forEach((d)=>d.destroy());
        emitter.off('brushAxis:remove', onRemove);
        emitter.off('brushAxis:highlight', onHighlight);
    };
}
function BrushAxisHighlight(options) {
    return (target, _, emitter)=>{
        const { container, view, options: viewOptions } = target;
        const plotArea = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectPlotArea"])(container);
        const { x: x0, y: y0 } = plotArea.getBBox();
        const { coordinate } = view;
        return brushAxisHighlight(container, Object.assign({
            elements: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectG2Elements"],
            axes: axesOf,
            offsetY: y0,
            offsetX: x0,
            points: (element)=>element.__data__.points,
            horizontal: (axis)=>{
                const { startPos: [sx, sy], endPos: [ex, ey] } = axis.attributes;
                // attention, non-horizontal does not mean vertical
                // it may has a specific degree angle
                return sx !== ex && sy === ey;
            },
            datum: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDatumof"])(view),
            state: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeState"])(viewOptions, [
                'active',
                [
                    'inactive',
                    {
                        opacity: 0.5
                    }
                ]
            ]),
            coordinate,
            emitter
        }, options));
    };
} //# sourceMappingURL=brushAxisHighlight.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/brushFilter.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "BrushFilter": (()=>BrushFilter),
    "brushFilter": (()=>brushFilter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/brushHighlight.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/scale.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/deep-mix.js [app-client] (ecmascript) <export default as deepMix>");
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
;
;
;
// Mock dblclick events.
function dblclick(interval = 300) {
    let preTimeStamp = null;
    return (e)=>{
        const { timeStamp } = e;
        if (preTimeStamp !== null && timeStamp - preTimeStamp < interval) {
            preTimeStamp = timeStamp;
            return true;
        }
        preTimeStamp = timeStamp;
        return false;
    };
}
function brushFilter(root, _a) {
    var { filter, reset, brushRegion, extent: optionalExtent, reverse, emitter, scale, coordinate, selection, series = false } = _a, rest = __rest(_a, [
        "filter",
        "reset",
        "brushRegion",
        "extent",
        "reverse",
        "emitter",
        "scale",
        "coordinate",
        "selection",
        "series"
    ]);
    const brushStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(rest, 'mask');
    const { width: rootWidth, height: rootHeight } = root.getBBox();
    const extent = optionalExtent ? optionalExtent : [
        0,
        0,
        rootWidth,
        rootHeight
    ];
    const isDblclick = dblclick();
    const brush = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["brush"])(root, Object.assign(Object.assign({}, brushStyle), {
        extent,
        brushRegion,
        reverse,
        brushcreated
    }));
    root.addEventListener('click', click);
    // Filter when brush created.
    function brushcreated(x, y, x1, y1, event) {
        event.nativeEvent = true;
        filter(selection(x, y, x1, y1), event);
        brush.remove();
    }
    // Reset when dblclick.
    function click(e) {
        if (isDblclick(e)) {
            e.nativeEvent = true;
            reset(e);
        }
    }
    const onFilter = ({ nativeEvent, data })=>{
        if (nativeEvent) return;
        const { selection } = data;
        filter(selection, {
            nativeEvent: false
        });
    };
    emitter.on('brush:filter', onFilter);
    return ()=>{
        brush.destroy();
        emitter.off('brush:filter', onFilter);
        root.removeEventListener('click', click);
    };
}
function BrushFilter(_a) {
    var { hideX = true, hideY = true } = _a, rest = __rest(_a, [
        "hideX",
        "hideY"
    ]);
    return (target, viewInstances, emitter)=>{
        const { container, view, options: viewOptions, update, setState } = target;
        const plotArea = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectPlotArea"])(container);
        const defaultOptions = {
            maskFill: '#777',
            maskFillOpacity: '0.3',
            maskStroke: '#fff',
            unhighlightedOpacity: 0.5,
            reverse: false
        };
        let filtered = false;
        let filtering = false;
        let newView = view;
        const { scale, coordinate } = view;
        return brushFilter(plotArea, Object.assign(Object.assign({
            brushRegion: (x, y, x1, y1)=>[
                    x,
                    y,
                    x1,
                    y1
                ],
            selection: (x, y, x1, y1)=>{
                const { scale, coordinate } = newView;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectionOf"])(x, y, x1, y1, scale, coordinate);
            },
            filter: (selection, event)=>__awaiter(this, void 0, void 0, function*() {
                    // Avoid redundant filter.
                    if (filtering) return;
                    filtering = true;
                    // Update the domain of x and y scale to filter data.
                    const [domainX, domainY] = selection;
                    setState('brushFilter', (options)=>{
                        const { marks } = options;
                        const newMarks = marks.map((mark)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({
                                // Hide label to keep smooth transition.
                                axis: Object.assign(Object.assign({}, hideX && {
                                    x: {
                                        transform: [
                                            {
                                                type: 'hide'
                                            }
                                        ]
                                    }
                                }), hideY && {
                                    y: {
                                        transform: [
                                            {
                                                type: 'hide'
                                            }
                                        ]
                                    }
                                })
                            }, mark, {
                                // Set nice to false to avoid modify domain.
                                scale: {
                                    x: {
                                        domain: domainX,
                                        nice: false
                                    },
                                    y: {
                                        domain: domainY,
                                        nice: false
                                    }
                                }
                            }));
                        return Object.assign(Object.assign({}, viewOptions), {
                            marks: newMarks,
                            clip: true
                        });
                    });
                    // Emit event.
                    emitter.emit('brush:filter', Object.assign(Object.assign({}, event), {
                        data: {
                            selection: [
                                domainX,
                                domainY
                            ]
                        }
                    }));
                    const newState = yield update();
                    newView = newState.view;
                    filtering = false;
                    filtered = true;
                }),
            reset: (event)=>{
                if (filtering || !filtered) return;
                // Emit event.
                const { scale } = view;
                const { x: scaleX, y: scaleY } = scale;
                const domainX = scaleX.getOptions().domain;
                const domainY = scaleY.getOptions().domain;
                emitter.emit('brush:filter', Object.assign(Object.assign({}, event), {
                    data: {
                        selection: [
                            domainX,
                            domainY
                        ]
                    }
                }));
                filtered = false;
                newView = view;
                setState('brushFilter');
                update();
            },
            extent: undefined,
            emitter,
            scale,
            coordinate
        }, defaultOptions), rest));
    };
} //# sourceMappingURL=brushFilter.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/brushXFilter.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "BrushXFilter": (()=>BrushXFilter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/brushFilter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushXHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/brushXHighlight.js [app-client] (ecmascript)");
;
;
function BrushXFilter(options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BrushFilter"])(Object.assign(Object.assign({
        hideX: true
    }, options), {
        brushRegion: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushXHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["brushXRegion"]
    }));
} //# sourceMappingURL=brushXFilter.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/brushYFilter.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "BrushYFilter": (()=>BrushYFilter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/brushFilter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushYHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/brushYHighlight.js [app-client] (ecmascript)");
;
;
function BrushYFilter(options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BrushFilter"])(Object.assign(Object.assign({
        hideY: true
    }, options), {
        brushRegion: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$brushYHighlight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["brushYRegion"]
    }));
} //# sourceMappingURL=brushYFilter.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/sliderFilter.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "SLIDER_CLASS_NAME": (()=>SLIDER_CLASS_NAME),
    "SliderFilter": (()=>SliderFilter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/g/dist/index.esm.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/deep-mix.js [app-client] (ecmascript) <export default as deepMix>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/scale.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/coordinate.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$upper$2d$first$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__upperFirst$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/upper-first.js [app-client] (ecmascript) <export default as upperFirst>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/throttle.js [app-client] (ecmascript) <export default as throttle>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g-lite/dist/index.esm.js [app-client] (ecmascript)");
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
;
;
;
;
const SLIDER_CLASS_NAME = 'slider';
function filterDataByDomain(options, scaleOptions, prefix, hasState = false, channel0 = 'x', channel1 = 'y') {
    const { marks } = options;
    const newMarks = marks.map((mark)=>{
        var _a, _b;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({
            // Hide label to keep smooth transition.
            axis: {
                x: {
                    transform: [
                        {
                            type: 'hide'
                        }
                    ]
                },
                y: {
                    transform: [
                        {
                            type: 'hide'
                        }
                    ]
                }
            }
        }, mark, {
            scale: scaleOptions,
            // Don't rerender sliders.
            [prefix]: Object.assign(Object.assign({}, ((_a = mark[prefix]) === null || _a === void 0 ? void 0 : _a[channel0]) && {
                [channel0]: Object.assign({
                    preserve: true
                }, hasState && {
                    ratio: null
                })
            }), ((_b = mark[prefix]) === null || _b === void 0 ? void 0 : _b[channel1]) && {
                [channel1]: {
                    preserve: true
                }
            }),
            animate: false
        });
    });
    // Rerender and update view.
    return Object.assign(Object.assign({}, options), {
        marks: newMarks,
        clip: true,
        animate: false
    });
}
function abstractValue(values, scale, reverse) {
    const [x, x1] = values;
    const v = reverse ? (d)=>1 - d : (d)=>d;
    const d0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["invert"])(scale, v(x), true);
    const d1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["invert"])(scale, v(x1), false);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["domainOf"])(scale, [
        d0,
        d1
    ]);
}
function extentOf(domain) {
    return [
        domain[0],
        domain[domain.length - 1]
    ];
}
function SliderFilter({ initDomain = {}, className = SLIDER_CLASS_NAME, prefix = 'slider', setValue = (component, values)=>component.setValues(values), hasState = false, wait = 50, leading = true, trailing = false, getInitValues = (slider)=>{
    var _a;
    const values = (_a = slider === null || slider === void 0 ? void 0 : slider.attributes) === null || _a === void 0 ? void 0 : _a.values;
    if (values[0] !== 0 || values[1] !== 1) return values;
} }) {
    return (context, _, emitter)=>{
        const { container, view, update, setState } = context;
        const sliders = container.getElementsByClassName(className);
        if (!sliders.length) return ()=>{};
        let filtering = false;
        const { scale, coordinate, layout } = view;
        const { paddingLeft, paddingTop, paddingBottom, paddingRight } = layout;
        const { x: scaleX, y: scaleY } = scale;
        const transposed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$coordinate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTranspose"])(coordinate);
        const channelOf = (orientation)=>{
            const channel0 = orientation === 'vertical' ? 'y' : 'x';
            const channel1 = orientation === 'vertical' ? 'x' : 'y';
            if (transposed) return [
                channel1,
                channel0
            ];
            return [
                channel0,
                channel1
            ];
        };
        const sliderHandler = new Map();
        const emitHandlers = new Set();
        // Store current domain of x and y scale.
        const channelDomain = {
            x: initDomain.x || scaleX.getOptions().domain,
            y: initDomain.y || scaleY.getOptions().domain
        };
        for (const slider of sliders){
            const { orientation } = slider.attributes;
            const [channel0, channel1] = channelOf(orientation);
            const eventName = `${prefix}${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$upper$2d$first$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__upperFirst$3e$__["upperFirst"])(channel0)}:filter`;
            const isX = channel0 === 'x';
            const { ratio: ratioX } = scaleX.getOptions();
            const { ratio: ratioY } = scaleY.getOptions();
            const domainsOf = (event)=>{
                // From abstract values.
                if (event.data) {
                    const { selection } = event.data;
                    const [X = extentOf(channelDomain.x), Y = extentOf(channelDomain.y)] = selection;
                    return isX ? [
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["domainOf"])(scaleX, X, ratioX),
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["domainOf"])(scaleY, Y, ratioY)
                    ] : [
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["domainOf"])(scaleY, Y, ratioY),
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["domainOf"])(scaleX, X, ratioX)
                    ];
                }
                // From visual values.
                const { value: values } = event.detail;
                const scale0 = scale[channel0];
                const domain0 = abstractValue(values, scale0, transposed && orientation === 'horizontal');
                const domain1 = channelDomain[channel1];
                return [
                    domain0,
                    domain1
                ];
            };
            const onValueChange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__throttle$3e$__["throttle"])((event)=>__awaiter(this, void 0, void 0, function*() {
                    const { initValue = false } = event;
                    if (filtering && !initValue) return;
                    filtering = true;
                    const { nativeEvent = true } = event;
                    // Get and update domain.
                    const [domain0, domain1] = domainsOf(event);
                    channelDomain[channel0] = domain0;
                    channelDomain[channel1] = domain1;
                    if (nativeEvent) {
                        // Emit events.
                        const X = isX ? domain0 : domain1;
                        const Y = isX ? domain1 : domain0;
                        emitter.emit(eventName, Object.assign(Object.assign({}, event), {
                            nativeEvent,
                            data: {
                                selection: [
                                    extentOf(X),
                                    extentOf(Y)
                                ]
                            }
                        }));
                    }
                    setState(slider, (options)=>Object.assign(Object.assign({}, filterDataByDomain(options, // Set nice to false to avoid modify domain.
                        // Only update domain of current slider / scrollbar.
                        {
                            [channel0]: {
                                domain: domain0,
                                nice: false
                            }
                        }, prefix, hasState, channel0, channel1)), {
                            paddingLeft,
                            paddingTop,
                            paddingBottom,
                            paddingRight
                        }));
                    yield update();
                    filtering = false;
                }), wait, {
                leading,
                trailing
            });
            const emitHandler = (event)=>{
                const { nativeEvent } = event;
                if (nativeEvent) return;
                const { data } = event;
                const { selection } = data;
                const [X, Y] = selection;
                // Update data.
                slider.dispatchEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CustomEvent"]('valuechange', {
                    data,
                    nativeEvent: false
                }));
                // Update slider.
                const V = isX ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["abstractOf"])(X, scaleX) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$scale$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["abstractOf"])(Y, scaleY);
                setValue(slider, V);
            };
            emitter.on(eventName, emitHandler);
            slider.addEventListener('valuechange', onValueChange);
            sliderHandler.set(slider, onValueChange);
            emitHandlers.add([
                eventName,
                emitHandler
            ]);
            const values = getInitValues(slider);
            if (values) {
                // Init values.
                slider.dispatchEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CustomEvent"]('valuechange', {
                    detail: {
                        value: values
                    },
                    nativeEvent: false,
                    initValue: true
                }));
            }
        }
        return ()=>{
            for (const [slider, handler] of sliderHandler){
                slider.removeEventListener('valuechange', handler);
            }
            for (const [name, handler] of emitHandlers){
                emitter.off(name, handler);
            }
        };
    };
} //# sourceMappingURL=sliderFilter.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/scrollbarFilter.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "SCROLLBAR_CLASS_NAME": (()=>SCROLLBAR_CLASS_NAME),
    "ScrollbarFilter": (()=>ScrollbarFilter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$sliderFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/sliderFilter.js [app-client] (ecmascript)");
;
const SCROLLBAR_CLASS_NAME = 'g2-scrollbar';
function ScrollbarFilter(options = {}) {
    return (context, _, emitter)=>{
        const { view, container } = context;
        const scrollbars = container.getElementsByClassName(SCROLLBAR_CLASS_NAME);
        if (!scrollbars.length) return ()=>{};
        const { scale } = view;
        const { x: scaleX, y: scaleY } = scale;
        // The filtered domain, computed by the ratio attribute.
        const initDomain = {
            x: [
                ...scaleX.getOptions().domain
            ],
            y: [
                ...scaleY.getOptions().domain
            ]
        };
        // The ordinal domain for each channel.
        scaleX.update({
            domain: scaleX.getOptions().expectedDomain
        });
        scaleY.update({
            domain: scaleY.getOptions().expectedDomain
        });
        const interaction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$sliderFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SliderFilter"])(Object.assign(Object.assign({}, options), {
            initDomain,
            className: SCROLLBAR_CLASS_NAME,
            prefix: 'scrollbar',
            hasState: true,
            setValue: (component, values)=>component.setValue(values[0]),
            getInitValues: (scrollbar)=>{
                const values = scrollbar.slider.attributes.values;
                if (values[0] !== 0) return values;
            }
        }));
        return interaction(context, _, emitter);
    };
} //# sourceMappingURL=scrollbarFilter.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/poptip.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Poptip": (()=>Poptip)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/g/dist/index.esm.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g-lite/dist/index.esm.js [app-client] (ecmascript)");
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
;
function dom(tag, children, style) {
    return `<${tag} style="${Object.entries(style).map(([key, value])=>`${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kebabCase"])(key)}:${value}`).join(';')}">${children}</${tag}>`;
}
const defaultTipStyle = {
    backgroundColor: 'rgba(0,0,0,0.75)',
    color: '#fff',
    width: 'max-content',
    padding: '1px 4px',
    fontSize: '12px',
    borderRadius: '2.5px',
    boxShadow: '0 3px 6px -4px rgba(0,0,0,0.12), 0 6px 16px 0 rgba(0,0,0,0.08), 0 9px 28px 8px rgba(0,0,0,0.05)'
};
function isTipText(element) {
    if (element.nodeName !== 'text') return false;
    if (element.isOverflowing()) return true;
    return false;
}
function Poptip(_a) {
    var { offsetX = 8, offsetY = 8 } = _a, style = __rest(_a, [
        "offsetX",
        "offsetY"
    ]);
    return (context)=>{
        const { container } = context;
        const [x0, y0] = container.getBounds().min;
        const tipStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(style, 'tip');
        const tips = new Set();
        const pointerover = (e)=>{
            const { target } = e;
            if (!isTipText(target)) {
                e.stopPropagation();
                return;
            }
            const { offsetX: mouseX, offsetY: mouseY } = e;
            const x = mouseX + offsetX - x0;
            const y = mouseY + offsetY - y0;
            if (target.tip) {
                target.tip.style.x = x;
                target.tip.style.y = y;
                return;
            }
            const { text } = target.style;
            const tipELement = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HTML"]({
                className: 'poptip',
                style: {
                    innerHTML: dom('div', text, Object.assign(Object.assign({}, defaultTipStyle), tipStyle)),
                    x,
                    y
                }
            });
            container.appendChild(tipELement);
            target.tip = tipELement;
            tips.add(tipELement);
        };
        const pointerout = (e)=>{
            const { target } = e;
            if (!isTipText(target)) {
                e.stopPropagation();
                return;
            }
            if (!target.tip) return;
            target.tip.remove();
            target.tip = null;
            tips.delete(target.tip);
        };
        container.addEventListener('pointerover', pointerover);
        container.addEventListener('pointerout', pointerout);
        return ()=>{
            container.removeEventListener('pointerover', pointerover);
            container.removeEventListener('pointerout', pointerout);
            tips.forEach((tip)=>tip.remove());
        };
    };
}
Poptip.props = {
    reapplyWhenUpdate: true
}; //# sourceMappingURL=poptip.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/treemapDrillDown.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "TreemapDrillDown": (()=>TreemapDrillDown)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/g/dist/index.esm.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$selection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/selection.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/runtime/constant.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/deep-mix.js [app-client] (ecmascript) <export default as deepMix>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g-lite/dist/index.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$size$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__size$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/size.js [app-client] (ecmascript) <export default as size>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/get.js [app-client] (ecmascript) <export default as get>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$legendFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/legendFilter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$treeDataTransform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/treeDataTransform.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$last$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__last$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/last.js [app-client] (ecmascript) <export default as last>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$find$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__find$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/find.js [app-client] (ecmascript) <export default as find>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$keys$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__keys$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/keys.js [app-client] (ecmascript) <export default as keys>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$pick$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pick$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/pick.js [app-client] (ecmascript) <export default as pick>");
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
;
;
;
;
;
;
function selectPlotArea(root) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$selection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["select"])(root).select(`.${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$runtime$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PLOT_CLASS_NAME"]}`).node();
}
// Default breadCrumb config.
const DEFAULT_BREADCRUMB_STYLE = {
    breadCrumbFill: 'rgba(0, 0, 0, 0.85)',
    breadCrumbFontSize: 12,
    breadCrumbY: 12,
    activeFill: 'rgba(0, 0, 0, 0.5)'
};
function TreemapDrillDown(drillDownOptions = {}) {
    const { originData = [], layout } = drillDownOptions, style = __rest(drillDownOptions, [
        "originData",
        "layout"
    ]);
    const breadCrumb = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({}, DEFAULT_BREADCRUMB_STYLE, style);
    const breadCrumbStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(breadCrumb, 'breadCrumb');
    const breadCrumbActiveStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(breadCrumb, 'active');
    return (context)=>{
        const { update, setState, container, options } = context;
        const plotArea = selectPlotArea(container);
        const mark = options.marks[0];
        const { state } = mark;
        // Create breadCrumbTextsGroup,save textSeparator、drillTexts.
        const textGroup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"]();
        plotArea.appendChild(textGroup);
        // Modify the data and scale according to the path and the level of the current click, so as to achieve the effect of drilling down and drilling up and initialization.
        const drillDownClick = (path, depth)=>__awaiter(this, void 0, void 0, function*() {
                // Clear text.
                textGroup.removeChildren();
                // More path creation text.
                if (depth) {
                    let name = '';
                    let y = breadCrumbStyle.y;
                    let x = 0;
                    const textPath = [];
                    const maxWidth = plotArea.getBBox().width;
                    // Create path: 'type1 / type2 / type3' -> '/ type1 / type2 / type3'.
                    const drillTexts = path.map((text, index)=>{
                        name = `${name}${text}/`;
                        textPath.push(text);
                        const drillText = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"]({
                            name: name.replace(/\/$/, ''),
                            style: Object.assign(Object.assign({
                                text,
                                x,
                                // @ts-ignore
                                path: [
                                    ...textPath
                                ],
                                depth: index
                            }, breadCrumbStyle), {
                                y
                            })
                        });
                        textGroup.appendChild(drillText);
                        x += drillText.getBBox().width;
                        const textSeparator = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"]({
                            style: Object.assign(Object.assign({
                                x,
                                text: ' / '
                            }, breadCrumbStyle), {
                                y
                            })
                        });
                        textGroup.appendChild(textSeparator);
                        x += textSeparator.getBBox().width;
                        /**
                     * Page width exceeds maximum, line feed.
                     * | ----maxWidth---- |
                     * | / tyep1 / tyep2 / type3 |
                     * ->
                     * | ----maxWidth---- |
                     * | / tyep1 / tyep2  |
                     * | / type3 |
                     */ if (x > maxWidth) {
                            y = textGroup.getBBox().height + breadCrumbStyle.y;
                            x = 0;
                            drillText.attr({
                                x,
                                y
                            });
                            x += drillText.getBBox().width;
                            textSeparator.attr({
                                x,
                                y
                            });
                            x += textSeparator.getBBox().width;
                        }
                        if (index === (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$size$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__size$3e$__["size"])(path) - 1) {
                            textSeparator.remove();
                        }
                        return drillText;
                    });
                    // Add Active, Add TreemapDrillDown
                    drillTexts.forEach((item, index)=>{
                        // Last drillText
                        if (index === (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$size$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__size$3e$__["size"])(drillTexts) - 1) return;
                        const originalAttrs = Object.assign({}, item.attributes);
                        item.attr('cursor', 'pointer');
                        item.addEventListener('mouseenter', ()=>{
                            item.attr(breadCrumbActiveStyle);
                        });
                        item.addEventListener('mouseleave', ()=>{
                            item.attr(originalAttrs);
                        });
                        item.addEventListener('click', ()=>{
                            drillDownClick((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(item, [
                                'style',
                                'path'
                            ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(item, [
                                'style',
                                'depth'
                            ]));
                        });
                    });
                }
                // LegendFilter interaction and treemapDrillDown clash.
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$legendFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["legendClearSetState"])(container, setState);
                // Update marks.
                setState('treemapDrillDown', (viewOptions)=>{
                    const { marks } = viewOptions;
                    // Add filter transform for every marks,
                    // which will skip for mark without color channel.
                    const strPath = path.join('/');
                    const newMarks = marks.map((mark)=>{
                        if (mark.type !== 'rect') return mark;
                        let newData = originData;
                        if (depth) {
                            const filterData = originData.filter((item)=>{
                                const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(item, [
                                    'id'
                                ]);
                                return id && (id.match(`${strPath}/`) || strPath.match(id));
                            }).map((item)=>({
                                    value: item.height === 0 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(item, [
                                        'value'
                                    ]) : undefined,
                                    name: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(item, [
                                        'id'
                                    ])
                                }));
                            const { paddingLeft, paddingBottom, paddingRight } = layout;
                            // New drill layout for calculation x y and filtration data.
                            const newLayout = Object.assign(Object.assign({}, layout), {
                                paddingTop: (layout.paddingTop || textGroup.getBBox().height + 10) / (depth + 1),
                                paddingLeft: paddingLeft / (depth + 1),
                                paddingBottom: paddingBottom / (depth + 1),
                                paddingRight: paddingRight / (depth + 1),
                                path: (d)=>d.name,
                                layer: (d)=>d.depth === depth + 1
                            });
                            // Transform the new matrix tree data.
                            newData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$treeDataTransform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["treeDataTransform"])(filterData, newLayout, {
                                value: 'value'
                            })[0];
                        } else {
                            newData = originData.filter((item)=>{
                                return item.depth === 1;
                            });
                        }
                        const colorDomain = [];
                        newData.forEach(({ path })=>{
                            colorDomain.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$last$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__last$3e$__["last"])(path));
                        });
                        // TreemapDrillDown by filtering the data and scale.
                        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({}, mark, {
                            data: newData,
                            scale: {
                                color: {
                                    domain: colorDomain
                                }
                            }
                        });
                    });
                    return Object.assign(Object.assign({}, viewOptions), {
                        marks: newMarks
                    });
                });
                // The second argument is to allow the legendFilter event to be re-added; the update method itself causes legend to lose the interaction event.
                yield update(undefined, [
                    'legendFilter'
                ]);
            });
        // Elements and BreadCrumb click.
        const createDrillClick = (e)=>{
            const item = e.target;
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(item, [
                'markType'
            ]) !== 'rect') return;
            const key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(item, [
                '__data__',
                'key'
            ]);
            const node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$find$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__find$3e$__["find"])(originData, (d)=>d.id === key);
            // Node height = 0 no children
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(node, 'height')) {
                drillDownClick((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(node, 'path'), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(node, 'depth'));
            }
        };
        // Add click drill interaction.
        plotArea.addEventListener('click', createDrillClick);
        // Change attributes keys.
        const changeStyleKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$keys$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__keys$3e$__["keys"])(Object.assign(Object.assign({}, state.active), state.inactive));
        const createActive = ()=>{
            const elements = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getElements"])(plotArea);
            elements.forEach((element)=>{
                const cursor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(element, [
                    'style',
                    'cursor'
                ]);
                const node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$find$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__find$3e$__["find"])(originData, (d)=>d.id === (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(element, [
                        '__data__',
                        'key'
                    ]));
                if (cursor !== 'pointer' && (node === null || node === void 0 ? void 0 : node.height)) {
                    element.style.cursor = 'pointer';
                    const originalAttrs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$pick$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pick$3e$__["pick"])(element.attributes, changeStyleKey);
                    element.addEventListener('mouseenter', ()=>{
                        element.attr(state.active);
                    });
                    element.addEventListener('mouseleave', ()=>{
                        element.attr((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])(originalAttrs, state.inactive));
                    });
                }
            });
        };
        createActive();
        // Animate elements update, Add active.
        plotArea.addEventListener('mousemove', createActive);
        return ()=>{
            textGroup.remove();
            plotArea.removeEventListener('click', createDrillClick);
            plotArea.removeEventListener('mousemove', createActive);
        };
    };
} //# sourceMappingURL=treemapDrillDown.js.map
}}),
"[project]/node_modules/@antv/g2/esm/interaction/elementPointMove.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ElementPointMove": (()=>ElementPointMove)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@antv/g/dist/index.esm.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/get.js [app-client] (ecmascript) <export default as get>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$find$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__find$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/find.js [app-client] (ecmascript) <export default as find>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g-lite/dist/index.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/interaction/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@antv/g2/esm/utils/helper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/deep-mix.js [app-client] (ecmascript) <export default as deepMix>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$is$2d$undefined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isUndefined$3e$__ = __turbopack_import__("[project]/node_modules/@antv/util/esm/lodash/is-undefined.js [app-client] (ecmascript) <export default as isUndefined>");
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
;
;
const DEFAULT_STYLE = {
    pointR: 6,
    pointStrokeWidth: 1,
    pointStroke: '#888',
    pointActiveStroke: '#f5f5f5',
    pathStroke: '#888',
    pathLineDash: [
        3,
        4
    ],
    labelFontSize: 12,
    labelFill: '#888',
    labelStroke: '#fff',
    labelLineWidth: 1,
    labelY: -6,
    labelX: 2
};
// point shape name.
const MOVE_POINT_NAME = 'movePoint';
// Element mouseenter change style.
const elementMouseenter = (e)=>{
    const element = e.target;
    const { markType } = element;
    // Mark line.
    if (markType === 'line') {
        element.attr('_lineWidth', element.attr('lineWidth') || 1);
        element.attr('lineWidth', element.attr('_lineWidth') + 3);
    }
    // Mark interval.
    if (markType === 'interval') {
        element.attr('_opacity', element.attr('opacity') || 1);
        element.attr('opacity', 0.7 * element.attr('_opacity'));
    }
};
// Element mouseleave change style.
const elementMouseleave = (e)=>{
    const element = e.target;
    const { markType } = element;
    // Mark line.
    if (markType === 'line') {
        element.attr('lineWidth', element.attr('_lineWidth'));
    }
    // Mark interval.
    if (markType === 'interval') {
        element.attr('opacity', element.attr('_opacity'));
    }
};
// Get the latest overall data based on the individual data changes.
const getNewData = (newChangeData, data, encode)=>{
    return data.map((d)=>{
        const isUpdate = [
            'x',
            'color'
        ].reduce((v, key)=>{
            const field = encode[key];
            if (!field) return v;
            if (d[field] !== newChangeData[field]) return false;
            return v;
        }, true);
        return isUpdate ? Object.assign(Object.assign({}, d), newChangeData) : d;
    });
};
// Find mark interval origin element data.
const getIntervalDataRatioTransformFn = (element)=>{
    const y = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(element, [
        '__data__',
        'y'
    ]);
    const y1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(element, [
        '__data__',
        'y1'
    ]);
    const v = y1 - y;
    const { __data__: { data, encode, transform }, childNodes } = element.parentNode;
    const isNormalizeY = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$find$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__find$3e$__["find"])(transform, ({ type })=>type === 'normalizeY');
    const yField = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(encode, [
        'y',
        'field'
    ]);
    const value = data[childNodes.indexOf(element)][yField];
    return (newValue, isTheta = false)=>{
        if (isNormalizeY || isTheta) {
            return newValue / (1 - newValue) / (v / (1 - v)) * value;
        }
        return newValue;
    };
};
// Find origin path data.
const getPathDataRatioTransformFn = (element, index)=>{
    const v = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(element, [
        '__data__',
        'seriesItems',
        index,
        '0',
        'value'
    ]);
    const i = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(element, [
        '__data__',
        'seriesIndex',
        index
    ]);
    const { __data__: { data, encode, transform } } = element.parentNode;
    const isNormalizeY = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$find$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__find$3e$__["find"])(transform, ({ type })=>type === 'normalizeY');
    const yField = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(encode, [
        'y',
        'field'
    ]);
    const value = data[i][yField];
    return (newValue)=>{
        if (isNormalizeY) {
            if (v === 1) {
                return newValue;
            }
            return newValue / (1 - newValue) / (v / (1 - v)) * value;
        }
        return newValue;
    };
};
// Point shape select change style.
const selectedPointsStyle = (pointsShape, selection, defaultStyle)=>{
    pointsShape.forEach((shape, index)=>{
        shape.attr('stroke', selection[1] === index ? defaultStyle['activeStroke'] : defaultStyle['stroke']);
    });
};
// Create help show message shape.
const createHelpShape = (group, circle, pathStyle, labelStyle)=>{
    const pathShape = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"]({
        style: pathStyle
    });
    const labelShape = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"]({
        style: labelStyle
    });
    circle.appendChild(labelShape);
    group.appendChild(pathShape);
    return [
        pathShape,
        labelShape
    ];
};
// Get color scale type.
const getColorType = (scaleColor, color)=>{
    const indexOf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(scaleColor, [
        'options',
        'range',
        'indexOf'
    ]);
    if (!indexOf) return;
    const i = scaleColor.options.range.indexOf(color);
    return scaleColor.sortedDomain[i];
};
// Get the same direction new point.
const getSamePointPosition = (center, point, target)=>{
    const oldR = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPointsR"])(center, point);
    const newR = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPointsR"])(center, target);
    const ratio = newR / oldR;
    const newX = center[0] + (point[0] - center[0]) * ratio;
    const newY = center[1] + (point[1] - center[1]) * ratio;
    return [
        newX,
        newY
    ];
};
function ElementPointMove(elementPointMoveOptions = {}) {
    const { selection = [], precision = 2 } = elementPointMoveOptions, style = __rest(elementPointMoveOptions, [
        "selection",
        "precision"
    ]);
    const defaultStyle = Object.assign(Object.assign({}, DEFAULT_STYLE), style || {});
    // Shape default style.
    const pathDefaultStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(defaultStyle, 'path');
    const labelDefaultStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(defaultStyle, 'label');
    const pointDefaultStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$utils$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subObject"])(defaultStyle, 'point');
    return (context, _, emitter)=>{
        const { update, setState, container, view, options: { marks, coordinate: coordinateOptions } } = context;
        const plotArea = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectPlotArea"])(container);
        let elements = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getElements"])(plotArea);
        let newState;
        let newSelection = selection;
        const { transform = [], type: coordinateType } = coordinateOptions;
        const isTranspose = !!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$find$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__find$3e$__["find"])(transform, ({ type })=>type === 'transpose');
        const isPolar = coordinateType === 'polar';
        const isTheta = coordinateType === 'theta';
        const isArea = !!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$find$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__find$3e$__["find"])(elements, ({ markType })=>markType === 'area');
        if (isArea) {
            elements = elements.filter(({ markType })=>markType === 'area');
        }
        // Create points
        const pointsGroup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"]({
            style: {
                // Tooltip point need down.
                zIndex: 2
            }
        });
        plotArea.appendChild(pointsGroup);
        const selectedChange = ()=>{
            emitter.emit('element-point:select', {
                nativeEvent: true,
                data: {
                    selection: newSelection
                }
            });
        };
        const dataChange = (changeData, data)=>{
            emitter.emit('element-point:moved', {
                nativeEvent: true,
                data: {
                    changeData,
                    data
                }
            });
        };
        // Element click change style.
        const elementClick = (e)=>{
            const element = e.target;
            newSelection = [
                element.parentNode.childNodes.indexOf(element)
            ];
            selectedChange();
            createPoints(element);
        };
        const elementSelect = (d)=>{
            const { data: { selection }, nativeEvent } = d;
            if (nativeEvent) return;
            newSelection = selection;
            const element = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__get$3e$__["get"])(elements, [
                newSelection === null || newSelection === void 0 ? void 0 : newSelection[0]
            ]);
            if (element) {
                createPoints(element);
            }
        };
        // Create select element points.
        const createPoints = (element)=>{
            const { attributes, markType, __data__: data } = element;
            const { stroke: fill } = attributes;
            const { points, seriesTitle, color, title, seriesX, y1 } = data;
            // Transpose Currently only do mark interval;
            if (isTranspose && markType !== 'interval') return;
            const { scale, coordinate } = (newState === null || newState === void 0 ? void 0 : newState.view) || view;
            const { color: scaleColor, y: scaleY, x: scaleX } = scale;
            const center = coordinate.getCenter();
            pointsGroup.removeChildren();
            let downPoint;
            const updateView = (x, y, color, markTypes)=>__awaiter(this, void 0, void 0, function*() {
                    setState('elementPointMove', (viewOptions)=>{
                        var _a;
                        // Update marks.
                        const newMarks = (((_a = newState === null || newState === void 0 ? void 0 : newState.options) === null || _a === void 0 ? void 0 : _a.marks) || marks).map((mark)=>{
                            if (!markTypes.includes(mark.type)) return mark;
                            const { data, encode } = mark;
                            const encodeKeys = Object.keys(encode);
                            // Get change new one element data.
                            const newChangeData = encodeKeys.reduce((value, key)=>{
                                const dataKey = encode[key];
                                if (key === 'x') {
                                    value[dataKey] = x;
                                }
                                if (key === 'y') {
                                    value[dataKey] = y;
                                }
                                if (key === 'color') {
                                    value[dataKey] = color;
                                }
                                return value;
                            }, {});
                            // Get change new all data.
                            const newData = getNewData(newChangeData, data, encode);
                            dataChange(newChangeData, newData);
                            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$deep$2d$mix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__deepMix$3e$__["deepMix"])({}, mark, {
                                data: newData,
                                // No need animate
                                animate: false
                            });
                        });
                        return Object.assign(Object.assign({}, viewOptions), {
                            marks: newMarks
                        });
                    });
                    return yield update('elementPointMove');
                });
            if ([
                'line',
                'area'
            ].includes(markType)) {
                points.forEach((p, index)=>{
                    const title = scaleX.invert(seriesX[index]);
                    // Area points have bottom point.
                    if (!title) return;
                    const circle = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Circle"]({
                        name: MOVE_POINT_NAME,
                        style: Object.assign({
                            cx: p[0],
                            cy: p[1],
                            fill
                        }, pointDefaultStyle)
                    });
                    const ratioTransform = getPathDataRatioTransformFn(element, index);
                    circle.addEventListener('mousedown', (e)=>{
                        const oldPoint = coordinate.output([
                            seriesX[index],
                            0
                        ]);
                        const pathLength = seriesTitle === null || seriesTitle === void 0 ? void 0 : seriesTitle.length;
                        container.attr('cursor', 'move');
                        if (newSelection[1] !== index) {
                            newSelection[1] = index;
                            selectedChange();
                        }
                        selectedPointsStyle(pointsGroup.childNodes, newSelection, pointDefaultStyle);
                        const [pathShape, labelShape] = createHelpShape(pointsGroup, circle, pathDefaultStyle, labelDefaultStyle);
                        // Point move change text
                        const pointMousemove = (e)=>{
                            const newCy = p[1] + e.clientY - downPoint[1];
                            // Area/Radar chart.
                            if (isArea) {
                                // Radar chart.
                                if (isPolar) {
                                    const newCx = p[0] + e.clientX - downPoint[0];
                                    const [newX, newY] = getSamePointPosition(center, oldPoint, [
                                        newCx,
                                        newCy
                                    ]);
                                    const [, initY] = coordinate.output([
                                        1,
                                        scaleY.output(0)
                                    ]);
                                    const [, y] = coordinate.invert([
                                        newX,
                                        initY - (points[index + pathLength][1] - newY)
                                    ]);
                                    const nextIndex = (index + 1) % pathLength;
                                    const lastIndex = (index - 1 + pathLength) % pathLength;
                                    const newPath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPointsPath"])([
                                        points[lastIndex],
                                        [
                                            newX,
                                            newY
                                        ],
                                        seriesTitle[nextIndex] && points[nextIndex]
                                    ]);
                                    labelShape.attr('text', ratioTransform(scaleY.invert(y)).toFixed(precision));
                                    pathShape.attr('d', newPath);
                                    circle.attr('cx', newX);
                                    circle.attr('cy', newY);
                                } else {
                                    // Area chart.
                                    const [, initY] = coordinate.output([
                                        1,
                                        scaleY.output(0)
                                    ]);
                                    const [, y] = coordinate.invert([
                                        p[0],
                                        initY - (points[index + pathLength][1] - newCy)
                                    ]);
                                    const newPath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPointsPath"])([
                                        points[index - 1],
                                        [
                                            p[0],
                                            newCy
                                        ],
                                        seriesTitle[index + 1] && points[index + 1]
                                    ]);
                                    labelShape.attr('text', ratioTransform(scaleY.invert(y)).toFixed(precision));
                                    pathShape.attr('d', newPath);
                                    circle.attr('cy', newCy);
                                }
                            } else {
                                // Line chart.
                                const [, y] = coordinate.invert([
                                    p[0],
                                    newCy
                                ]);
                                const newPath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPointsPath"])([
                                    points[index - 1],
                                    [
                                        p[0],
                                        newCy
                                    ],
                                    points[index + 1]
                                ]);
                                labelShape.attr('text', scaleY.invert(y).toFixed(precision));
                                pathShape.attr('d', newPath);
                                circle.attr('cy', newCy);
                            }
                        };
                        downPoint = [
                            e.clientX,
                            e.clientY
                        ];
                        window.addEventListener('mousemove', pointMousemove);
                        const mouseupFn = ()=>__awaiter(this, void 0, void 0, function*() {
                                container.attr('cursor', 'default');
                                window.removeEventListener('mousemove', pointMousemove);
                                container.removeEventListener('mouseup', mouseupFn);
                                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$is$2d$undefined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isUndefined$3e$__["isUndefined"])(labelShape.attr('text'))) return;
                                const y = Number(labelShape.attr('text'));
                                const colorType = getColorType(scaleColor, color);
                                newState = yield updateView(title, y, colorType, [
                                    'line',
                                    'area'
                                ]);
                                labelShape.remove();
                                pathShape.remove();
                                createPoints(element);
                            });
                        container.addEventListener('mouseup', mouseupFn);
                    });
                    pointsGroup.appendChild(circle);
                });
                selectedPointsStyle(pointsGroup.childNodes, newSelection, pointDefaultStyle);
            } else if (markType === 'interval') {
                // Column chart point.
                let circlePoint = [
                    (points[0][0] + points[1][0]) / 2,
                    points[0][1]
                ];
                // Bar chart point.
                if (isTranspose) {
                    circlePoint = [
                        points[0][0],
                        (points[0][1] + points[1][1]) / 2
                    ];
                } else if (isTheta) {
                    // Pie chart point.
                    circlePoint = points[0];
                }
                const ratioTransform = getIntervalDataRatioTransformFn(element);
                const circle = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g$2d$lite$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Circle"]({
                    name: MOVE_POINT_NAME,
                    style: Object.assign(Object.assign({
                        cx: circlePoint[0],
                        cy: circlePoint[1],
                        fill
                    }, pointDefaultStyle), {
                        stroke: pointDefaultStyle['activeStroke']
                    })
                });
                circle.addEventListener('mousedown', (e)=>{
                    container.attr('cursor', 'move');
                    const colorType = getColorType(scaleColor, color);
                    const [pathShape, labelShape] = createHelpShape(pointsGroup, circle, pathDefaultStyle, labelDefaultStyle);
                    // Point move change text
                    const pointMousemove = (e)=>{
                        if (isTranspose) {
                            // Bar chart.
                            const newCx = circlePoint[0] + e.clientX - downPoint[0];
                            const [initX] = coordinate.output([
                                scaleY.output(0),
                                scaleY.output(0)
                            ]);
                            const [, x] = coordinate.invert([
                                initX + (newCx - points[2][0]),
                                circlePoint[1]
                            ]);
                            const newPath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPointsPath"])([
                                [
                                    newCx,
                                    points[0][1]
                                ],
                                [
                                    newCx,
                                    points[1][1]
                                ],
                                points[2],
                                points[3]
                            ], true);
                            labelShape.attr('text', ratioTransform(scaleY.invert(x)).toFixed(precision));
                            pathShape.attr('d', newPath);
                            circle.attr('cx', newCx);
                        } else if (isTheta) {
                            // Pie chart.
                            const newCy = circlePoint[1] + e.clientY - downPoint[1];
                            const newCx = circlePoint[0] + e.clientX - downPoint[0];
                            const [newXOut, newYOut] = getSamePointPosition(center, [
                                newCx,
                                newCy
                            ], circlePoint);
                            const [newXIn, newYIn] = getSamePointPosition(center, [
                                newCx,
                                newCy
                            ], points[1]);
                            const lastPercent = coordinate.invert([
                                newXOut,
                                newYOut
                            ])[1];
                            const percent = y1 - lastPercent;
                            if (percent < 0) return;
                            const newPath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getThetaPath"])(center, [
                                [
                                    newXOut,
                                    newYOut
                                ],
                                [
                                    newXIn,
                                    newYIn
                                ],
                                points[2],
                                points[3]
                            ], percent > 0.5 ? 1 : 0);
                            labelShape.attr('text', ratioTransform(percent, true).toFixed(precision));
                            pathShape.attr('d', newPath);
                            circle.attr('cx', newXOut);
                            circle.attr('cy', newYOut);
                        } else {
                            // Column chart.
                            const newCy = circlePoint[1] + e.clientY - downPoint[1];
                            const [, initY] = coordinate.output([
                                1,
                                scaleY.output(0)
                            ]);
                            const [, y] = coordinate.invert([
                                circlePoint[0],
                                initY - (points[2][1] - newCy)
                            ]);
                            const newPath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$g2$2f$esm$2f$interaction$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPointsPath"])([
                                [
                                    points[0][0],
                                    newCy
                                ],
                                [
                                    points[1][0],
                                    newCy
                                ],
                                points[2],
                                points[3]
                            ], true);
                            labelShape.attr('text', ratioTransform(scaleY.invert(y)).toFixed(precision));
                            pathShape.attr('d', newPath);
                            circle.attr('cy', newCy);
                        }
                    };
                    downPoint = [
                        e.clientX,
                        e.clientY
                    ];
                    window.addEventListener('mousemove', pointMousemove);
                    // Change mosueup change data and update 、clear shape.
                    const mouseupFn = ()=>__awaiter(this, void 0, void 0, function*() {
                            container.attr('cursor', 'default');
                            container.removeEventListener('mouseup', mouseupFn);
                            window.removeEventListener('mousemove', pointMousemove);
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$antv$2f$util$2f$esm$2f$lodash$2f$is$2d$undefined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isUndefined$3e$__["isUndefined"])(labelShape.attr('text'))) return;
                            const y = Number(labelShape.attr('text'));
                            newState = yield updateView(title, y, colorType, [
                                markType
                            ]);
                            labelShape.remove();
                            pathShape.remove();
                            createPoints(element);
                        });
                    container.addEventListener('mouseup', mouseupFn);
                });
                pointsGroup.appendChild(circle);
            }
        };
        // Add EventListener.
        elements.forEach((element, index)=>{
            if (newSelection[0] === index) {
                createPoints(element);
            }
            element.addEventListener('click', elementClick);
            element.addEventListener('mouseenter', elementMouseenter);
            element.addEventListener('mouseleave', elementMouseleave);
        });
        const rootClick = (e)=>{
            const element = e === null || e === void 0 ? void 0 : e.target;
            if (!element || element.name !== MOVE_POINT_NAME && !elements.includes(element)) {
                newSelection = [];
                selectedChange();
                pointsGroup.removeChildren();
            }
        };
        emitter.on('element-point:select', elementSelect);
        emitter.on('element-point:unselect', rootClick);
        container.addEventListener('mousedown', rootClick);
        // Remove EventListener.
        return ()=>{
            pointsGroup.remove();
            emitter.off('element-point:select', elementSelect);
            emitter.off('element-point:unselect', rootClick);
            container.removeEventListener('mousedown', rootClick);
            elements.forEach((element)=>{
                element.removeEventListener('click', elementClick);
                element.removeEventListener('mouseenter', elementMouseenter);
                element.removeEventListener('mouseleave', elementMouseleave);
            });
        };
    };
} //# sourceMappingURL=elementPointMove.js.map
}}),
}]);

//# sourceMappingURL=node_modules_%40antv_g2_esm_interaction_d5a42b._.js.map